diff -Naur a/Source/JavaScriptCore/bytecode/CodeBlock.cpp b/Source/JavaScriptCore/bytecode/CodeBlock.cpp
--- a/Source/JavaScriptCore/bytecode/CodeBlock.cpp	2016-07-06 13:02:43.706445100 -0700
+++ b/Source/JavaScriptCore/bytecode/CodeBlock.cpp	2016-07-11 15:34:06.878734466 -0700
@@ -86,6 +86,9 @@
     return CodeBlockHash(ownerExecutable()->source(), specializationKind());
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2000)
+
 String CodeBlock::sourceCodeForTools() const
 {
     if (codeType() != FunctionCode)
@@ -107,6 +110,14 @@
 
 String CodeBlock::sourceCodeOnOneLine() const
 {
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "@S+CodeBlock::sourceCodeOnOneLine()%n", ra);
+    }
+
     return reduceWhitespace(sourceCodeForTools());
 }
 
diff -Naur a/Source/JavaScriptCore/interpreter/Interpreter.cpp b/Source/JavaScriptCore/interpreter/Interpreter.cpp
--- a/Source/JavaScriptCore/interpreter/Interpreter.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/JavaScriptCore/interpreter/Interpreter.cpp	2016-07-06 13:02:43.722445100 -0700
@@ -791,6 +791,11 @@
     Interpreter* m_interpreter;
 };
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2000)
+#define MAXSTRLEN 128
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+
 JSValue Interpreter::execute(ProgramExecutable* program, CallFrame* callFrame, JSObject* thisObj)
 {
     SamplingScope samplingScope(this);
@@ -939,6 +944,9 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->willExecute(callFrame, program->sourceURL(), program->lineNo());
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+JS1 [%s]", program->sourceURL().utf8().data());
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A+JS1");
+
     // Execute the code:
     JSValue result;
     {
@@ -952,14 +960,18 @@
 #endif // ENABLE(JIT)
     }
 
-    if (LegacyProfiler* profiler = vm.enabledProfiler())
+    if (LegacyProfiler* profiler = vm.enabledProfiler()) 
         profiler->didExecute(callFrame, program->sourceURL(), program->lineNo());
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JS1");
+
+
     m_stack.popFrame(newCallFrame);
 
     return checkedReturn(result);
 }
 
+
 JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
 {
     VM& vm = callFrame->vm();
@@ -1013,6 +1025,15 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->willExecute(callFrame, function);
 
+    if (tditrace_ex != NULL) {
+        const String& thename = getCalculatedDisplayName(callFrame, function);
+        char s[64 + 1];
+        strncpy(s, newCodeBlock ? newCodeBlock->sourceCodeOnOneLine().utf8().data() : "?", 64);
+        s[64] = '\0';
+        tditrace_ex(TDIMASK, "@S+JS2 \'%s\':\'%s%s\'", thename.utf8().data(), s, newCodeBlock ? strlen(newCodeBlock->sourceCodeOnOneLine().utf8().data()) > 64 ? "..." : "" : "");
+        tditrace_ex(TDIMASK, "@A+JS2");
+    }
+
     JSValue result;
     {
         SamplingTool::CallRecord callRecord(m_sampler.get(), !isJSCall);
@@ -1032,6 +1053,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->didExecute(callFrame, function);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JS2");
+
     m_stack.popFrame(newCallFrame);
     return checkedReturn(result);
 }
@@ -1091,6 +1114,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->willExecute(callFrame, constructor);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A+JS3");
+
     JSValue result;
     {
         SamplingTool::CallRecord callRecord(m_sampler.get(), !isJSConstruct);
@@ -1110,6 +1135,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->didExecute(callFrame, constructor);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JS3");
+
     m_stack.popFrame(newCallFrame);
 
     if (callFrame->hadException())
@@ -1176,6 +1203,15 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->willExecute(closure.oldCallFrame, closure.function);
 
+    if (tditrace_ex != NULL) {
+        FunctionCodeBlock* newCodeBlock = &closure.functionExecutable->generatedBytecodeForCall();
+        char s[64 + 1];
+        strncpy(s, newCodeBlock ? newCodeBlock->sourceCodeOnOneLine().utf8().data() : "?", 64);
+        s[64] = '\0';
+        tditrace_ex(TDIMASK, "@S+JS4 \'%s%s\'", s, strlen(newCodeBlock->sourceCodeOnOneLine().utf8().data()) > 64 ? "..." : "");
+        tditrace_ex(TDIMASK, "@A+JS4");
+    }
+
     if (UNLIKELY(vm.watchdog.didFire(closure.oldCallFrame)))
         return throwTerminatedExecutionException(closure.oldCallFrame);
 
@@ -1205,6 +1241,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->didExecute(closure.oldCallFrame, closure.function);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JS4");
+
     m_stack.validateFence(closure.newCallFrame, "AFTER");
     return checkedReturn(result);
 }
@@ -1288,6 +1326,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->willExecute(callFrame, eval->sourceURL(), eval->lineNo());
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A+JS5");
+
     // Execute the code:
     JSValue result;
     {
@@ -1304,6 +1344,8 @@
     if (LegacyProfiler* profiler = vm.enabledProfiler())
         profiler->didExecute(callFrame, eval->sourceURL(), eval->lineNo());
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JS5");
+
     m_stack.popFrame(newCallFrame);
     return checkedReturn(result);
 }
diff -Naur a/Source/JavaScriptCore/jit/JIT.cpp b/Source/JavaScriptCore/jit/JIT.cpp
--- a/Source/JavaScriptCore/jit/JIT.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/JavaScriptCore/jit/JIT.cpp	2016-07-06 13:02:43.722445100 -0700
@@ -562,12 +562,25 @@
     }
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2000)
+
 JITCode JIT::privateCompile(CodePtr* functionEntryArityCheck, JITCompilationEffort effort)
 {
+
+    if (tditrace_ex != NULL) {
+        char s[64 + 1];
+        strncpy(s, m_codeBlock->sourceCodeOnOneLine().utf8().data(), 64);
+        s[64] = '\0';
+        tditrace_ex(TDIMASK, "@S+JIT %s%s", s, strlen(m_codeBlock->sourceCodeOnOneLine().utf8().data()) > 64 ? "..." : "");
+        tditrace_ex(TDIMASK, "@A+JIT");
+    }
+
+
 #if ENABLE(JIT_VERBOSE_OSR)
     printf("Compiling JIT code!\n");
 #endif
-    
+
 #if ENABLE(VALUE_PROFILER)
     DFG::CapabilityLevel level = m_codeBlock->canCompileWithDFG();
     switch (level) {
@@ -619,6 +632,9 @@
     Jump stackCheck;
     if (m_codeBlock->codeType() == FunctionCode) {
 #if ENABLE(DFG_JIT)
+
+
+
 #if DFG_ENABLE(SUCCESS_STATS)
         static SamplingCounter counter("orignalJIT");
         emitCount(counter);
@@ -798,7 +814,10 @@
 #if ENABLE(JIT_VERBOSE)
     dataLogF("JIT generated code for %p at [%p, %p).\n", m_codeBlock, result.executableMemory()->start(), result.executableMemory()->end());
 #endif
-    
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@A-JIT");
+    //fprintf(stderr, "%p at [%p, %p) %s\n", m_codeBlock, result.executableMemory()->start(), result.executableMemory()->end(), m_codeBlock->sourceCodeOnOneLine().utf8().data());
+
     return JITCode(result, JITCode::BaselineJIT);
 }
 
diff -Naur a/Source/WebCore/dom/ContainerNodeAlgorithms.h b/Source/WebCore/dom/ContainerNodeAlgorithms.h
--- a/Source/WebCore/dom/ContainerNodeAlgorithms.h	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WebCore/dom/ContainerNodeAlgorithms.h	2016-07-06 13:02:43.722445100 -0700
@@ -29,6 +29,10 @@
 #include "NodeTraversal.h"
 #include <wtf/Assertions.h>
 
+#include <wtf/text/CString.h>
+#include <wtf/text/WTFString.h>
+#include <wtf/text/StringBuilder.h>
+
 namespace WebCore {
 
 class ChildNodeInsertionNotifier {
@@ -211,8 +215,49 @@
     notifyDescendantInsertedIntoTree(node);
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x8)
+
 inline void ChildNodeInsertionNotifier::notify(Node* node)
 {
+
+    if (tditrace_ex != NULL) {
+        StringBuilder name;
+        if (Element* element = node && node->isElementNode() ? toElement(node) : 0) {
+            name.append(element->tagName());
+
+            if (element->hasID()) {
+                name.appendLiteral(" id=\'");
+                name.append(element->getIdAttribute());
+                name.append('\'');
+            }
+
+            if (element->hasClass()) {
+                name.appendLiteral(" class=\'");
+                for (size_t i = 0; i < element->classNames().size(); ++i) {
+                    if (i > 0)
+                        name.append(' ');
+                    name.append(element->classNames()[i]);
+                }
+                name.append('\'');
+            }
+        }
+
+        char text[256];
+        int i;
+        if (name.toString().is8Bit()) {
+            i = name.toString().length() < 255 ? name.toString().length() : 255;
+            strncpy(text, (char*)name.toString().characters8(), i);
+        } else {
+            char* p = (char*)name.toString().characters8();
+            for (i = 0 ; i < (name.toString().length() < 255 ? name.toString().length() : 255) ; i++) {
+                text[i] = p[i];
+            }
+        }
+        text[i]=0;
+        tditrace_ex(TDIMASK, "@S+DOM %s", text);
+    }
+
     ASSERT(!NoEventDispatchAssertion::isEventDispatchForbidden());
 
 #if ENABLE(INSPECTOR)
diff -Naur a/Source/WebCore/dom/Document.cpp b/Source/WebCore/dom/Document.cpp
--- a/Source/WebCore/dom/Document.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/dom/Document.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -167,6 +167,9 @@
 #include <wtf/PassRefPtr.h>
 #include <wtf/text/StringBuffer.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x4)
+
 #if USE(ACCELERATED_COMPOSITING)
 #include "RenderLayerCompositor.h"
 #endif
@@ -1779,6 +1782,8 @@
 
     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(this);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+Document::recalcStyle()");
+
     if (m_elemSheet && m_elemSheet->contents()->usesRemUnits())
         m_styleSheetCollection->setUsesRemUnit(true);
 
@@ -1849,6 +1854,8 @@
 
     InspectorInstrumentation::didRecalculateStyle(cookie);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-Document::recalcStyle()");
+
     // As a result of the style recalculation, the currently hovered element might have been
     // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
     // to check if any other elements ended up under the mouse pointer due to re-layout.
diff -Naur a/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp b/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
--- a/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -58,6 +58,9 @@
 #include "TextMetrics.h"
 #include "TextRun.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x10)
+
 #if USE(ACCELERATED_COMPOSITING)
 #include "RenderLayer.h"
 #endif
@@ -1039,6 +1042,9 @@
         return;
     FloatRect rect(x, y, width, height);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+CanvasRenderingContext2D::clearRect() %dx%d+%d+%d", (int)rect.width(), (int)rect.height(), (int)rect.x(), (int)rect.y());
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+CanvasRenderingContext2D::clearRect() %dx%d+%d+%d", (int)rect.width(), (int)rect.height(), (int)rect.x(), (int)rect.y());
+
     bool saved = false;
     if (shouldDrawShadows()) {
         context->save();
@@ -1063,6 +1069,8 @@
     if (saved)
         context->restore();
     didDraw(rect);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-CanvasRenderingContext2D::clearRect()");
 }
 
 void CanvasRenderingContext2D::fillRect(float x, float y, float width, float height)
@@ -1085,6 +1093,9 @@
 
     FloatRect rect(x, y, width, height);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+CanvasRenderingContext2D::fillRect() %dx%d+%d+%d", (int)rect.width(), (int)rect.height(), (int)rect.x(), (int)rect.y());
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+CanvasRenderingContext2D::fillRect() %dx%d+%d+%d", (int)rect.width(), (int)rect.height(), (int)rect.x(), (int)rect.y());
+
     if (rectContainsCanvas(rect)) {
         c->fillRect(rect);
         didDrawEntireCanvas();
@@ -1099,6 +1110,8 @@
         c->fillRect(rect);
         didDraw(rect);
     }
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-CanvasRenderingContext2D::fillRect()");
 }
 
 void CanvasRenderingContext2D::strokeRect(float x, float y, float width, float height)
@@ -2083,12 +2096,46 @@
 
 void CanvasRenderingContext2D::fillText(const String& text, float x, float y)
 {
+    char t[128];
+    int i;
+    if (text.is8Bit()) {
+        i = text.length() < 127 ? text.length() : 127;
+        strncpy(t, (char*)text.characters8(), i);
+    } else {
+        char* p = (char*)text.characters16();
+        for (i = 0 ; i < (text.length() < 127 ? text.length() : 127) ; i++) {
+            t[i] = p[0+i*2];
+        }
+    }
+    t[i]=0;
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+CanvasRenderingContext2D::fillText() \"%s\"", t);
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+CanvasRenderingContext2D::fillText() \"%s\"", t);
+
     drawTextInternal(text, x, y, true);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-CanvasRenderingContext2D::fillText()");
 }
 
 void CanvasRenderingContext2D::fillText(const String& text, float x, float y, float maxWidth)
 {
+    if (text.is8Bit()) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+CanvasRenderingContext2D::fillText() \"%s\"", (char*)text.characters8());
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+CanvasRenderingContext2D::fillText() \"%s\"", (char*)text.characters8());
+    } else {
+        char t[128];
+        int i;
+        char* p = (char*)text.characters16();
+        for (i = 0 ; i < (text.length() < 127 ? text.length() : 127) ; i++) {
+            t[i] = p[0+i*2];
+        }
+        t[i]=0;
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+CanvasRenderingContext2D::fillText() \"%s\"", t);
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+CanvasRenderingContext2D::fillText() \"%s\"", t);
+    }
+
     drawTextInternal(text, x, y, true, maxWidth, true);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-CanvasRenderingContext2D::fillText()");
 }
 
 void CanvasRenderingContext2D::strokeText(const String& text, float x, float y)
diff -Naur a/Source/WebCore/html/canvas/WebGLRenderingContext.cpp b/Source/WebCore/html/canvas/WebGLRenderingContext.cpp
--- a/Source/WebCore/html/canvas/WebGLRenderingContext.cpp	2015-06-05 16:52:24.890936700 -0700
+++ b/Source/WebCore/html/canvas/WebGLRenderingContext.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -84,6 +84,9 @@
 #undef emit
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x20)
+
 namespace WebCore {
 
 const double secondsBetweenRestoreAttempts = 1.0;
@@ -418,6 +421,8 @@
         return nullptr;
     }
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+WebGLRenderingContext::create()");
+
     HostWindow* hostWindow = document->view()->root()->hostWindow();
     GraphicsContext3D::Attributes attributes = attrs ? attrs->attributes() : GraphicsContext3D::Attributes();
 
@@ -434,6 +439,7 @@
 
     if (!context || !context->makeContextCurrent()) {
         canvas->dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent, false, true, "Could not create a WebGL context."));
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-WebGLRenderingContext::create()");
         return nullptr;
     }
 
@@ -444,6 +450,7 @@
     OwnPtr<WebGLRenderingContext> renderingContext = adoptPtr(new WebGLRenderingContext(canvas, context, attributes));
     renderingContext->suspendIfNeeded();
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-WebGLRenderingContext::create()");
     return renderingContext.release();
 }
 
@@ -667,6 +674,8 @@
         || m_attributes.preserveDrawingBuffer || (mask && m_framebufferBinding))
         return false;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+WebGLRenderingContext::clearIfComposited()");
+
     RefPtr<WebGLContextAttributes> contextAttributes = getContextAttributes();
 
     // Determine if it's possible to combine the clear the user asked for and this clear.
@@ -709,6 +718,8 @@
         m_context->bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
     m_layerCleared = true;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-WebGLRenderingContext::clearIfComposited()");
+
     return combinedClear;
 }
 
diff -Naur a/Source/WebCore/loader/cache/CachedScript.cpp b/Source/WebCore/loader/cache/CachedScript.cpp
--- a/Source/WebCore/loader/cache/CachedScript.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WebCore/loader/cache/CachedScript.cpp	2016-07-11 15:34:42.450362081 -0700
@@ -68,8 +68,19 @@
     return extractMIMETypeFromMediaType(m_response.httpHeaderField("Content-Type")).lower();
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x1000)
+
 const String& CachedScript::script()
 {
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "@S+CachedScript::script()%n", ra);
+    }
+
     ASSERT(!isPurgeable());
 
     if (!m_script && m_data) {
@@ -91,6 +102,14 @@
 
 void CachedScript::destroyDecodedData()
 {
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "@S+CachedScript::destroyDecodedData()%n", ra);
+    }
+
     m_script = String();
     setDecodedSize(0);
     if (!MemoryCache::shouldMakeResourcePurgeableOnEviction() && isSafeToMakePurgeable())
diff -Naur a/Source/WebCore/loader/TextResourceDecoder.cpp b/Source/WebCore/loader/TextResourceDecoder.cpp
--- a/Source/WebCore/loader/TextResourceDecoder.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WebCore/loader/TextResourceDecoder.cpp	2016-07-11 15:34:52.052812275 -0700
@@ -607,8 +607,19 @@
         && (m_source == DefaultEncoding || (m_source == EncodingFromParentFrame && m_hintEncoding)); 
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x1000)
+
 String TextResourceDecoder::decode(const char* data, size_t len)
 {
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "@S+TextResourceDecoder::decode() %d%n", len, ra);
+    }
+
     size_t lengthOfBOM = 0;
     if (!m_checkedForBOM)
         lengthOfBOM = checkForBOM(data, len);
diff -Naur a/Source/WebCore/page/Console.cpp b/Source/WebCore/page/Console.cpp
--- a/Source/WebCore/page/Console.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/page/Console.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -156,9 +156,25 @@
     internalAddMessage(page(), ClearMessageType, LogMessageLevel, state, arguments, true);
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x1)
+
 void Console::trace(ScriptState* state, PassRefPtr<ScriptArguments> arguments)
 {
-    internalAddMessage(page(), TraceMessageType, LogMessageLevel, state, arguments, true, true);
+    //internalAddMessage(page(), TraceMessageType, LogMessageLevel, state, arguments, true, true);
+
+    if (tditrace_ex != NULL) {
+        for (size_t i = 0; i < arguments->argumentCount(); ++i) {
+            String argAsString = arguments->argumentAt(i).toString(arguments->globalState());
+            tditrace_ex(TDIMASK, "%s", argAsString.utf8().data());
+        }
+       // size_t stackSize = ScriptCallStack::maxCallStackSizeToCapture;
+       // RefPtr<ScriptCallStack> callStack(createScriptCallStack(state, stackSize));
+       // for (size_t i = 0; i < callStack->size(); ++i) {
+       //     String functionName = String(callStack->at(i).functionName());
+       //     fprintf(stderr, "\t%s\n", functionName.utf8().data());
+       // }
+    }
 }
 
 void Console::assertCondition(ScriptState* state, PassRefPtr<ScriptArguments> arguments, bool condition)
diff -Naur a/Source/WebCore/page/DOMTimer.cpp b/Source/WebCore/page/DOMTimer.cpp
--- a/Source/WebCore/page/DOMTimer.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/page/DOMTimer.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -35,6 +35,9 @@
 #include <wtf/HashSet.h>
 #include <wtf/StdLibExtras.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x8)
+
 using namespace std;
 
 namespace WebCore {
@@ -87,6 +90,8 @@
     timer->suspendIfNeeded();
     InspectorInstrumentation::didInstallTimer(context, timer->m_timeoutId, timeout, singleShot);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+DOMTimer:: install,%dms,%d", timeout, timer->m_timeoutId);
+
     return timer->m_timeoutId;
 }
 
@@ -100,6 +105,8 @@
 
     InspectorInstrumentation::didRemoveTimer(context, timeoutId);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+DOMTimer:: removeById,%d", timeoutId);
+
     delete context->findTimeout(timeoutId);
 }
 
@@ -114,6 +121,8 @@
 
     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireTimer(context, m_timeoutId);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+DOMTimer:: fired,%d", m_timeoutId);
+
     // Simple case for non-one-shot timers.
     if (isActive()) {
         double minimumInterval = context->minimumTimerInterval();
diff -Naur a/Source/WebCore/page/FrameView.cpp b/Source/WebCore/page/FrameView.cpp
--- a/Source/WebCore/page/FrameView.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/page/FrameView.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -77,6 +77,9 @@
 #include "TextResourceDecoder.h"
 #include "TextStream.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x800)
+
 #include <wtf/CurrentTime.h>
 #include <wtf/TemporaryChange.h>
 
@@ -3596,9 +3599,12 @@
     if (needsLayout())
         return;
 
-    if (!p->paintingDisabled())
+    if (!p->paintingDisabled()) {
         InspectorInstrumentation::willPaint(renderView);
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+FrameView::paintContents()");
+    }
+
     bool isTopLevelPainter = !sCurrentPaintTimeStamp;
     if (isTopLevelPainter)
         sCurrentPaintTimeStamp = currentTime();
@@ -3663,6 +3669,9 @@
 
     if (!p->paintingDisabled()) {
         InspectorInstrumentation::didPaint(renderView, p, rect);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-FrameView::paintContents()");
+
         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
         firePaintRelatedMilestones();
     }
diff -Naur a/Source/WebCore/platform/graphics/GraphicsContext.cpp b/Source/WebCore/platform/graphics/GraphicsContext.cpp
--- a/Source/WebCore/platform/graphics/GraphicsContext.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/graphics/GraphicsContext.cpp	2016-07-06 13:02:43.758445100 -0700
@@ -36,6 +36,9 @@
 
 #include "stdio.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x80)
+
 using namespace std;
 
 namespace WebCore {
@@ -414,7 +417,26 @@
     if (paintingDisabled())
         return;
 
+    if (tditrace_ex != NULL) {
+        char text[128];
+        int i;
+        if (run.is8Bit()) {
+            i = run.length() < 127 ? run.length() : 127;
+            strncpy(text, (char*)run.characters8(), i);
+        } else {
+            char* p = (char*)run.characters16();
+            for (i = 0 ; i < (run.length() < 127 ? run.length() : 127) ; i++) {
+                text[i] = p[0+i*2];
+            }
+        }
+        text[i]=0;
+        tditrace_ex(TDIMASK, "@S+GraphicsContext::drawText() \"%s\"", text);
+        tditrace_ex(TDIMASK, "@T+GraphicsContext::drawText() \"%s\"", text);
+    }
+
     font.drawText(this, run, point, from, to);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::drawText()");
 }
 #endif
 
@@ -504,6 +526,8 @@
 {    if (paintingDisabled() || !image)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::drawImage() %dx%d+%d+%d", (int)dest.width(), (int)dest.height(), (int)dest.x(), (int)dest.y());
+
     InterpolationQuality previousInterpolationQuality = InterpolationDefault;
 
     if (useLowQualityScale) {
@@ -516,6 +540,8 @@
 
     if (useLowQualityScale)
         setImageInterpolationQuality(previousInterpolationQuality);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::drawImage()");
 }
 
 void GraphicsContext::drawTiledImage(Image* image, ColorSpace styleColorSpace, const IntRect& destRect, const IntPoint& srcPoint, const IntSize& tileSize, CompositeOperator op, bool useLowQualityScale, BlendMode blendMode)
diff -Naur a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLCommon.cpp b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLCommon.cpp
--- a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLCommon.cpp	2015-06-05 16:52:24.954936700 -0700
+++ b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLCommon.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -67,6 +67,9 @@
 #include <BlackBerryPlatformLog.h>
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x400)
+
 namespace WebCore {
 
 PassRefPtr<GraphicsContext3D> GraphicsContext3D::createForCurrentGLContext()
@@ -161,6 +164,7 @@
         return;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (m_attrs.antialias)
         resolveMultisamplingIfNecessary();
 
@@ -183,6 +187,7 @@
         return;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     bool mustRestoreFBO = false;
     if (m_attrs.antialias) {
@@ -221,6 +226,8 @@
     if (width == m_currentWidth && height == m_currentHeight)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3D::reshape()");
+
 #if (PLATFORM(QT) || PLATFORM(EFL)) && USE(GRAPHICS_SURFACE)
     m_functions->glFlush(); // Make sure all GL calls have been committed before resizing.
     createGraphicsSurfaces(IntSize(width, height));
@@ -290,6 +297,8 @@
         m_functions->glBindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_state.boundFBO);
 
     m_functions->glFlush();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::reshape()");
 }
 
 IntSize GraphicsContext3D::getInternalFramebufferSize() const
@@ -300,6 +309,7 @@
 void GraphicsContext3D::activeTexture(GC3Denum texture)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_state.activeTexture = texture;
     m_functions->glActiveTexture(texture);
 }
@@ -309,6 +319,7 @@
     ASSERT(program);
     ASSERT(shader);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glAttachShader(program, shader);
 }
 
@@ -316,18 +327,21 @@
 {
     ASSERT(program);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBindAttribLocation(program, index, name.utf8().data());
 }
 
 void GraphicsContext3D::bindBuffer(GC3Denum target, Platform3DObject buffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBindBuffer(target, buffer);
 }
 
 void GraphicsContext3D::bindFramebuffer(GC3Denum target, Platform3DObject buffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLuint fbo;
     if (buffer)
         fbo = buffer;
@@ -346,6 +360,7 @@
 void GraphicsContext3D::bindRenderbuffer(GC3Denum target, Platform3DObject renderbuffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBindRenderbuffer(target, renderbuffer);
 }
 
@@ -353,6 +368,7 @@
 void GraphicsContext3D::bindTexture(GC3Denum target, Platform3DObject texture)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (m_state.activeTexture == GL_TEXTURE0 && target == GL_TEXTURE_2D)
         m_state.boundTexture0 = texture;
     m_functions->glBindTexture(target, texture);
@@ -361,18 +377,21 @@
 void GraphicsContext3D::blendColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBlendColor(red, green, blue, alpha);
 }
 
 void GraphicsContext3D::blendEquation(GC3Denum mode)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBlendEquation(mode);
 }
 
 void GraphicsContext3D::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBlendEquationSeparate(modeRGB, modeAlpha);
 }
 
@@ -380,60 +399,73 @@
 void GraphicsContext3D::blendFunc(GC3Denum sfactor, GC3Denum dfactor)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBlendFunc(sfactor, dfactor);
 }       
 
 void GraphicsContext3D::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 }
 
 void GraphicsContext3D::bufferData(GC3Denum target, GC3Dsizeiptr size, GC3Denum usage)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBufferData(target, size, 0, usage);
 }
 
 void GraphicsContext3D::bufferData(GC3Denum target, GC3Dsizeiptr size, const void* data, GC3Denum usage)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBufferData(target, size, data, usage);
 }
 
 void GraphicsContext3D::bufferSubData(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr size, const void* data)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glBufferSubData(target, offset, size, data);
 }
 
 GC3Denum GraphicsContext3D::checkFramebufferStatus(GC3Denum target)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glCheckFramebufferStatus(target);
 }
 
 void GraphicsContext3D::clearColor(GC3Dclampf r, GC3Dclampf g, GC3Dclampf b, GC3Dclampf a)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glClearColor(r, g, b, a);
 }
 
 void GraphicsContext3D::clear(GC3Dbitfield mask)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3D::clear()");
+
     makeContextCurrent();
     m_functions->glClear(mask);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::clear()");
 }
 
 void GraphicsContext3D::clearStencil(GC3Dint s)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glClearStencil(s);
 }
 
 void GraphicsContext3D::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glColorMask(red, green, blue, alpha);
 }
 
@@ -441,6 +473,7 @@
 {
     ASSERT(shader);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     String translatedShaderSource = m_extensions->getTranslatedShaderSourceANGLE(shader);
 
@@ -485,6 +518,7 @@
 void GraphicsContext3D::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 #if !PLATFORM(BLACKBERRY)
     if (m_attrs.antialias && m_state.boundFBO == m_multisampleFBO) {
         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
@@ -501,6 +535,7 @@
 void GraphicsContext3D::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 #if !PLATFORM(BLACKBERRY)
     if (m_attrs.antialias && m_state.boundFBO == m_multisampleFBO) {
         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
@@ -517,18 +552,21 @@
 void GraphicsContext3D::cullFace(GC3Denum mode)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glCullFace(mode);
 }
 
 void GraphicsContext3D::depthFunc(GC3Denum func)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDepthFunc(func);
 }
 
 void GraphicsContext3D::depthMask(GC3Dboolean flag)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDepthMask(flag);
 }
 
@@ -537,78 +575,91 @@
     ASSERT(program);
     ASSERT(shader);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDetachShader(program, shader);
 }
 
 void GraphicsContext3D::disable(GC3Denum cap)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDisable(cap);
 }
 
 void GraphicsContext3D::disableVertexAttribArray(GC3Duint index)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDisableVertexAttribArray(index);
 }
 
 void GraphicsContext3D::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDrawArrays(mode, first, count);
 }
 
 void GraphicsContext3D::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDrawElements(mode, count, type, reinterpret_cast<GLvoid*>(static_cast<intptr_t>(offset)));
 }
 
 void GraphicsContext3D::enable(GC3Denum cap)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glEnable(cap);
 }
 
 void GraphicsContext3D::enableVertexAttribArray(GC3Duint index)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glEnableVertexAttribArray(index);
 }
 
 void GraphicsContext3D::finish()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFinish();
 }
 
 void GraphicsContext3D::flush()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFlush();
 }
 
 void GraphicsContext3D::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject buffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFramebufferRenderbuffer(target, attachment, renderbuffertarget, buffer);
 }
 
 void GraphicsContext3D::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject texture, GC3Dint level)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFramebufferTexture2D(target, attachment, textarget, texture, level);
 }
 
 void GraphicsContext3D::frontFace(GC3Denum mode)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFrontFace(mode);
 }
 
 void GraphicsContext3D::generateMipmap(GC3Denum target)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGenerateMipmap(target);
 }
 
@@ -619,6 +670,7 @@
         return false;
     }
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLint maxAttributeSize = 0;
     m_functions->glGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &maxAttributeSize);
     OwnArrayPtr<GLchar> name = adoptArrayPtr(new GLchar[maxAttributeSize]); // GL_ACTIVE_ATTRIBUTE_MAX_LENGTH includes null termination.
@@ -645,6 +697,7 @@
     }
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLint maxUniformSize = 0;
     m_functions->glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxUniformSize);
 
@@ -671,6 +724,7 @@
         return;
     }
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetAttachedShaders(program, maxCount, count, shaders);
 }
 
@@ -720,6 +774,7 @@
         return -1;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     // The attribute name may have been translated during ANGLE compilation.
     // Look through the corresponding ShaderSourceMap to make sure we
@@ -744,18 +799,21 @@
     }
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glGetError();
 }
 
 String GraphicsContext3D::getString(GC3Denum name)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return String(reinterpret_cast<const char*>(m_functions->glGetString(name)));
 }
 
 void GraphicsContext3D::hint(GC3Denum target, GC3Denum mode)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glHint(target, mode);
 }
 
@@ -765,12 +823,14 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsBuffer(buffer);
 }
 
 GC3Dboolean GraphicsContext3D::isEnabled(GC3Denum cap)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsEnabled(cap);
 }
 
@@ -780,6 +840,7 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsFramebuffer(framebuffer);
 }
 
@@ -789,6 +850,7 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsProgram(program);
 }
 
@@ -798,6 +860,7 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsRenderbuffer(renderbuffer);
 }
 
@@ -807,6 +870,7 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsShader(shader);
 }
 
@@ -816,12 +880,14 @@
         return GL_FALSE;
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glIsTexture(texture);
 }
 
 void GraphicsContext3D::lineWidth(GC3Dfloat width)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glLineWidth(width);
 }
 
@@ -829,30 +895,35 @@
 {
     ASSERT(program);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glLinkProgram(program);
 }
 
 void GraphicsContext3D::pixelStorei(GC3Denum pname, GC3Dint param)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glPixelStorei(pname, param);
 }
 
 void GraphicsContext3D::polygonOffset(GC3Dfloat factor, GC3Dfloat units)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glPolygonOffset(factor, units);
 }
 
 void GraphicsContext3D::sampleCoverage(GC3Dclampf value, GC3Dboolean invert)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glSampleCoverage(value, invert);
 }
 
 void GraphicsContext3D::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glScissor(x, y, width, height);
 }
 
@@ -861,6 +932,7 @@
     ASSERT(shader);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     ShaderSourceEntry entry;
 
@@ -872,66 +944,77 @@
 void GraphicsContext3D::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilFunc(func, ref, mask);
 }
 
 void GraphicsContext3D::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilFuncSeparate(face, func, ref, mask);
 }
 
 void GraphicsContext3D::stencilMask(GC3Duint mask)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilMask(mask);
 }
 
 void GraphicsContext3D::stencilMaskSeparate(GC3Denum face, GC3Duint mask)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilMaskSeparate(face, mask);
 }
 
 void GraphicsContext3D::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilOp(fail, zfail, zpass);
 }
 
 void GraphicsContext3D::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glStencilOpSeparate(face, fail, zfail, zpass);
 }
 
 void GraphicsContext3D::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glTexParameterf(target, pname, value);
 }
 
 void GraphicsContext3D::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glTexParameteri(target, pname, value);
 }
 
 void GraphicsContext3D::uniform1f(GC3Dint location, GC3Dfloat v0)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform1f(location, v0);
 }
 
 void GraphicsContext3D::uniform1fv(GC3Dint location, GC3Dsizei size, GC3Dfloat* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform1fv(location, size, array);
 }
 
 void GraphicsContext3D::uniform2f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform2f(location, v0, v1);
 }
 
@@ -939,12 +1022,14 @@
 {
     // FIXME: length needs to be a multiple of 2.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform2fv(location, size, array);
 }
 
 void GraphicsContext3D::uniform3f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform3f(location, v0, v1, v2);
 }
 
@@ -952,12 +1037,14 @@
 {
     // FIXME: length needs to be a multiple of 3.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform3fv(location, size, array);
 }
 
 void GraphicsContext3D::uniform4f(GC3Dint location, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform4f(location, v0, v1, v2, v3);
 }
 
@@ -965,24 +1052,28 @@
 {
     // FIXME: length needs to be a multiple of 4.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform4fv(location, size, array);
 }
 
 void GraphicsContext3D::uniform1i(GC3Dint location, GC3Dint v0)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform1i(location, v0);
 }
 
 void GraphicsContext3D::uniform1iv(GC3Dint location, GC3Dsizei size, GC3Dint* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform1iv(location, size, array);
 }
 
 void GraphicsContext3D::uniform2i(GC3Dint location, GC3Dint v0, GC3Dint v1)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform2i(location, v0, v1);
 }
 
@@ -990,12 +1081,14 @@
 {
     // FIXME: length needs to be a multiple of 2.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform2iv(location, size, array);
 }
 
 void GraphicsContext3D::uniform3i(GC3Dint location, GC3Dint v0, GC3Dint v1, GC3Dint v2)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform3i(location, v0, v1, v2);
 }
 
@@ -1003,12 +1096,14 @@
 {
     // FIXME: length needs to be a multiple of 3.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform3iv(location, size, array);
 }
 
 void GraphicsContext3D::uniform4i(GC3Dint location, GC3Dint v0, GC3Dint v1, GC3Dint v2, GC3Dint v3)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform4i(location, v0, v1, v2, v3);
 }
 
@@ -1016,6 +1111,7 @@
 {
     // FIXME: length needs to be a multiple of 4.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniform4iv(location, size, array);
 }
 
@@ -1023,6 +1119,7 @@
 {
     // FIXME: length needs to be a multiple of 4.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniformMatrix2fv(location, size, transpose, array);
 }
 
@@ -1030,6 +1127,7 @@
 {
     // FIXME: length needs to be a multiple of 9.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniformMatrix3fv(location, size, transpose, array);
 }
 
@@ -1037,12 +1135,14 @@
 {
     // FIXME: length needs to be a multiple of 16.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUniformMatrix4fv(location, size, transpose, array);
 }
 
 void GraphicsContext3D::useProgram(Platform3DObject program)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glUseProgram(program);
 }
 
@@ -1051,90 +1151,105 @@
     ASSERT(program);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glValidateProgram(program);
 }
 
 void GraphicsContext3D::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib1f(index, v0);
 }
 
 void GraphicsContext3D::vertexAttrib1fv(GC3Duint index, GC3Dfloat* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib1fv(index, array);
 }
 
 void GraphicsContext3D::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib2f(index, v0, v1);
 }
 
 void GraphicsContext3D::vertexAttrib2fv(GC3Duint index, GC3Dfloat* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib2fv(index, array);
 }
 
 void GraphicsContext3D::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib3f(index, v0, v1, v2);
 }
 
 void GraphicsContext3D::vertexAttrib3fv(GC3Duint index, GC3Dfloat* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib3fv(index, array);
 }
 
 void GraphicsContext3D::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib4f(index, v0, v1, v2, v3);
 }
 
 void GraphicsContext3D::vertexAttrib4fv(GC3Duint index, GC3Dfloat* array)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttrib4fv(index, array);
 }
 
 void GraphicsContext3D::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, GC3Dintptr offset)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast<GLvoid*>(static_cast<intptr_t>(offset)));
 }
 
 void GraphicsContext3D::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glViewport(x, y, width, height);
 }
 
 void GraphicsContext3D::getBooleanv(GC3Denum pname, GC3Dboolean* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetBooleanv(pname, value);
 }
 
 void GraphicsContext3D::getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetBufferParameteriv(target, pname, value);
 }
 
 void GraphicsContext3D::getFloatv(GC3Denum pname, GC3Dfloat* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetFloatv(pname, value);
 }
 
 void GraphicsContext3D::getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (attachment == DEPTH_STENCIL_ATTACHMENT)
         attachment = DEPTH_ATTACHMENT; // Or STENCIL_ATTACHMENT, either works.
     m_functions->glGetFramebufferAttachmentParameteriv(target, attachment, pname, value);
@@ -1143,6 +1258,7 @@
 void GraphicsContext3D::getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetProgramiv(program, pname, value);
 }
 
@@ -1151,6 +1267,7 @@
     ASSERT(program);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLint length = 0;
     m_functions->glGetProgramiv(program, GL_INFO_LOG_LENGTH, &length);
     if (!length)
@@ -1166,6 +1283,7 @@
 void GraphicsContext3D::getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetRenderbufferParameteriv(target, pname, value);
 }
 
@@ -1174,6 +1292,7 @@
     ASSERT(shader);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);
     
@@ -1209,6 +1328,7 @@
     ASSERT(shader);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);
     if (result == m_shaderSourceMap.end())
@@ -1235,6 +1355,7 @@
     ASSERT(shader);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);
     if (result == m_shaderSourceMap.end())
@@ -1247,24 +1368,28 @@
 void GraphicsContext3D::getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetTexParameterfv(target, pname, value);
 }
 
 void GraphicsContext3D::getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetTexParameteriv(target, pname, value);
 }
 
 void GraphicsContext3D::getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetUniformfv(program, location, value);
 }
 
 void GraphicsContext3D::getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetUniformiv(program, location, value);
 }
 
@@ -1273,6 +1398,7 @@
     ASSERT(program);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     // The uniform name may have been translated during ANGLE compilation.
     // Look through the corresponding ShaderSourceMap to make sure we
@@ -1285,18 +1411,21 @@
 void GraphicsContext3D::getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetVertexAttribfv(index, pname, value);
 }
 
 void GraphicsContext3D::getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetVertexAttribiv(index, pname, value);
 }
 
 GC3Dsizeiptr GraphicsContext3D::getVertexAttribOffset(GC3Duint index, GC3Denum pname)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     GLvoid* pointer = 0;
     m_functions->glGetVertexAttribPointerv(index, pname, &pointer);
@@ -1306,6 +1435,7 @@
 void GraphicsContext3D::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoff, GC3Dint yoff, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, const void* pixels)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
 
     // FIXME: we will need to deal with PixelStore params when dealing with image buffers that differ from the subimage size.
     m_functions->glTexSubImage2D(target, level, xoff, yoff, width, height, format, type, pixels);
@@ -1314,18 +1444,21 @@
 void GraphicsContext3D::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Dsizei imageSize, const void* data)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
 }
 
 void GraphicsContext3D::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Dsizei imageSize, const void* data)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
 }
 
 Platform3DObject GraphicsContext3D::createBuffer()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLuint o = 0;
     m_functions->glGenBuffers(1, &o);
     return o;
@@ -1334,6 +1467,7 @@
 Platform3DObject GraphicsContext3D::createFramebuffer()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLuint o = 0;
     m_functions->glGenFramebuffers(1, &o);
     return o;
@@ -1342,12 +1476,14 @@
 Platform3DObject GraphicsContext3D::createProgram()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glCreateProgram();
 }
 
 Platform3DObject GraphicsContext3D::createRenderbuffer()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLuint o = 0;
     m_functions->glGenRenderbuffers(1, &o);
     return o;
@@ -1356,12 +1492,14 @@
 Platform3DObject GraphicsContext3D::createShader(GC3Denum type)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     return m_functions->glCreateShader((type == FRAGMENT_SHADER) ? GL_FRAGMENT_SHADER : GL_VERTEX_SHADER);
 }
 
 Platform3DObject GraphicsContext3D::createTexture()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     GLuint o = 0;
     m_functions->glGenTextures(1, &o);
     return o;
@@ -1370,12 +1508,14 @@
 void GraphicsContext3D::deleteBuffer(Platform3DObject buffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDeleteBuffers(1, &buffer);
 }
 
 void GraphicsContext3D::deleteFramebuffer(Platform3DObject framebuffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (framebuffer == m_state.boundFBO) {
         // Make sure the framebuffer is not going to be used for drawing
         // operations after it gets deleted.
@@ -1387,24 +1527,28 @@
 void GraphicsContext3D::deleteProgram(Platform3DObject program)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDeleteProgram(program);
 }
 
 void GraphicsContext3D::deleteRenderbuffer(Platform3DObject renderbuffer)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDeleteRenderbuffers(1, &renderbuffer);
 }
 
 void GraphicsContext3D::deleteShader(Platform3DObject shader)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDeleteShader(shader);
 }
 
 void GraphicsContext3D::deleteTexture(Platform3DObject texture)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (m_state.boundTexture0 == texture)
         m_state.boundTexture0 = 0;
     m_functions->glDeleteTextures(1, &texture);
@@ -1433,6 +1577,7 @@
 void GraphicsContext3D::texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
 }
 
diff -Naur a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGL.cpp b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGL.cpp
--- a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGL.cpp	2015-06-05 16:52:24.946936700 -0700
+++ b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGL.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -77,10 +77,14 @@
 
 namespace WebCore {
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x400)
+
 void GraphicsContext3D::releaseShaderCompiler()
 {
     ASSERT(m_private);
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glReleaseShaderCompiler();
 }
 
@@ -246,6 +250,7 @@
 void GraphicsContext3D::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (!isGLES2Compliant()) {
         switch (internalformat) {
         case DEPTH_STENCIL:
@@ -269,6 +274,7 @@
 void GraphicsContext3D::getIntegerv(GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     if (!isGLES2Compliant()) {
         // Need to emulate MAX_FRAGMENT/VERTEX_UNIFORM_VECTORS and MAX_VARYING_VECTORS
         // because desktop GL's corresponding queries return the number of components
@@ -301,6 +307,7 @@
     ASSERT(precision);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
 }
 
@@ -339,12 +346,14 @@
 void GraphicsContext3D::depthRange(GC3Dclampf zNear, GC3Dclampf zFar)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glDepthRangef(zNear, zFar);
 }
 
 void GraphicsContext3D::clearDepth(GC3Dclampf depth)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glClearDepthf(depth);
 }
 
@@ -361,6 +370,7 @@
     // FIXME: remove the two glFlush calls when the driver bug is fixed, i.e.,
     // all previous rendering calls should be done before reading pixels.
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     m_functions->glFlush();
     if (m_attrs.antialias && m_state.boundFBO == m_multisampleFBO) {
         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
diff -Naur a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLES.cpp b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLES.cpp
--- a/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLES.cpp	2015-06-05 16:52:24.962936700 -0700
+++ b/Source/WebCore/platform/graphics/opengl/GraphicsContext3DOpenGLES.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -40,17 +40,23 @@
 #endif
 #include "NotImplemented.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x400)
+
+
 namespace WebCore {
 
 void GraphicsContext3D::releaseShaderCompiler()
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glReleaseShaderCompiler();
 }
 
 void GraphicsContext3D::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, void* data)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     // FIXME: remove the two glFlush calls when the driver bug is fixed, i.e.,
     // all previous rendering calls should be done before reading pixels.
     ::glFlush();
@@ -177,12 +183,14 @@
 void GraphicsContext3D::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glRenderbufferStorage(target, internalformat, width, height);
 }
 
 void GraphicsContext3D::getIntegerv(GC3Denum pname, GC3Dint* value)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glGetIntegerv(pname, value);
 }
 
@@ -192,6 +200,7 @@
     ASSERT(precision);
 
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
 }
 
@@ -220,12 +229,14 @@
 void GraphicsContext3D::depthRange(GC3Dclampf zNear, GC3Dclampf zFar)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glDepthRangef(zNear, zFar);
 }
 
 void GraphicsContext3D::clearDepth(GC3Dclampf depth)
 {
     makeContextCurrent();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext3D:: %s", __func__);
     ::glClearDepthf(depth);
 }
 
diff -Naur a/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp b/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp
--- a/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp	2016-04-13 13:51:34.752574900 -0700
+++ b/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -33,6 +33,9 @@
 #include <qpa/qplatformpixmap.h>
 #include <wtf/text/CString.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x100)
+
 #include <private/qopenglextensions_p.h>
 #include <QOffscreenSurface>
 
@@ -262,15 +265,18 @@
 #if USE(ACCELERATED_COMPOSITING)
 void GraphicsContext3DPrivate::paintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& matrix, float opacity)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3DPrivate::paintToTextureMapper()");
+
     m_context->markLayerComposited();
-    if (m_context->m_attrs.antialias)
-        blitMultisampleFramebufferAndRestoreContext();
+    blitMultisampleFramebufferAndRestoreContext();
 
     if (textureMapper->accelerationMode() == TextureMapper::OpenGLMode) {
         TextureMapperGL* texmapGL = static_cast<TextureMapperGL*>(textureMapper);
         TextureMapperGL::Flags flags = TextureMapperGL::ShouldFlipTexture | (m_context->m_attrs.alpha ? TextureMapperGL::ShouldBlend : 0);
         IntSize textureSize(m_context->m_currentWidth, m_context->m_currentHeight);
         texmapGL->drawTexture(m_context->m_texture, flags, textureSize, targetRect, matrix, opacity);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3DPrivate::paintToTextureMapper()");
         return;
     }
 
@@ -294,6 +300,8 @@
 
     painter->drawImage(targetRect, offscreenImage);
     painter->restore();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3DPrivate::paintToTextureMapper()");
 }
 #endif // USE(ACCELERATED_COMPOSITING)
 
@@ -341,6 +349,8 @@
 
 void GraphicsContext3DPrivate::blitMultisampleFramebufferAndRestoreContext()
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3DPrivate::blitMultisampleFramebufferAndRestoreContext()");
+
     const QOpenGLContext* currentContext = QOpenGLContext::currentContext();
     QSurface* currentSurface = 0;
     if (currentContext && currentContext != m_platformContext) {
@@ -357,6 +367,8 @@
 
     if (currentContext && currentContext != m_platformContext)
         const_cast<QOpenGLContext*>(currentContext)->makeCurrent(currentSurface);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3DPrivate::blitMultisampleFramebufferAndRestoreContext()");
 }
 
 bool GraphicsContext3DPrivate::makeCurrentIfNeeded() const
@@ -411,6 +423,8 @@
         return;
     }
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3D::GraphicsContext3D()");
+
     m_functions = m_private.get();
     validateAttributes();
 
@@ -431,6 +445,8 @@
 
     if (renderStyle != RenderToCurrentGLContext)
         m_functions->glClearColor(0.0, 0.0, 0.0, 0.0);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::GraphicsContext3D()");
 }
 
 GraphicsContext3D::~GraphicsContext3D()
@@ -439,6 +455,8 @@
     if (!m_private)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3D::~GraphicsContext3D()");
+
     makeContextCurrent();
     m_functions->glDeleteTextures(1, &m_texture);
     m_functions->glDeleteFramebuffers(1, &m_fbo);
@@ -458,6 +476,8 @@
     }
 
     m_functions = 0;
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::~GraphicsContext3D()");
 }
 
 PlatformGraphicsContext3D GraphicsContext3D::platformGraphicsContext3D()
@@ -479,9 +499,15 @@
 
 bool GraphicsContext3D::makeContextCurrent()
 {
-    if (!m_private)
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext3D::makeContextCurrent()");
+
+    if (!m_private) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::makeContextCurrent()");
         return false;
-    return m_private->makeCurrentIfNeeded();
+    }
+    bool b = m_private->makeCurrentIfNeeded();
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext3D::makeContextCurrent()");
+    return b;
 }
 
 void GraphicsContext3D::paintToCanvas(const unsigned char* imagePixels, int imageWidth, int imageHeight,
diff -Naur a/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp b/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp
--- a/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -73,6 +73,9 @@
 #include <QVector>
 #include <wtf/MathExtras.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x100)
+
 #if OS(WINDOWS)
 QT_BEGIN_NAMESPACE
 Q_GUI_EXPORT QPixmap qt_pixmapFromWinHBITMAP(HBITMAP, int hbitmapFormat = 0);
@@ -832,8 +835,12 @@
     if (!repeatX || !repeatY)
         p->setClipRect(clip);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)targetRect.width(), (int)targetRect.height(), (int)targetRect.x(), (int)targetRect.y(), "brush");
+
     p->fillRect(targetRect, brush);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
+
     if (!oldClip.isEmpty())
         p->setClipRegion(oldClip);
     else if (!repeatX || !repeatY)
@@ -874,7 +881,13 @@
                 shadow.endShadowLayer(this);
             }
         }
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)normalizedRect.width(), (int)normalizedRect.height(), (int)normalizedRect.x(), (int)normalizedRect.y(), "brush");
+
         p->fillRect(normalizedRect, brush);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
+
     } else {
         if (hasShadow()) {
             if (mustUseShadowBlur()) {
@@ -895,11 +908,20 @@
                 // faster without using the shadow layer at all.
                 QColor shadowColor = m_state.shadowColor;
                 shadowColor.setAlphaF(shadowColor.alphaF() * p->brush().color().alphaF());
+
+                if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)normalizedRect.width(), (int)normalizedRect.height(), (int)normalizedRect.x(), (int)normalizedRect.y(), "color");
+
                 p->fillRect(normalizedRect.translated(QPointF(m_state.shadowOffset.width(), m_state.shadowOffset.height())), shadowColor);
+
+                if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
             }
         }
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)normalizedRect.width(), (int)normalizedRect.height(), (int)normalizedRect.x(), (int)normalizedRect.y(), "brush");
+
         p->fillRect(normalizedRect, p->brush());
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
     }
 }
 
@@ -909,6 +931,10 @@
     if (paintingDisabled() || !color.isValid())
         return;
 
+    QColor qcolor = QColor(color);
+    int r,g,b,a;
+    qcolor.getRgb(&r, &g, &b, &a);
+
     QRectF platformRect(rect);
     QPainter* p = m_data->p();
     if (hasShadow()) {
@@ -918,10 +944,20 @@
         } else {
             QColor shadowColor = m_state.shadowColor;
             shadowColor.setAlphaF(shadowColor.alphaF() * p->brush().color().alphaF());
+
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)platformRect.width(), (int)platformRect.height(), (int)platformRect.x(), (int)platformRect.y(), "color");
+
             p->fillRect(platformRect.translated(QPointF(m_state.shadowOffset.width(), m_state.shadowOffset.height())), shadowColor);
+
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
         }
     }
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::fillRect() %dx%d+%d+%d,%s", (int)platformRect.width(), (int)platformRect.height(), (int)platformRect.x(), (int)platformRect.y(), "color");
+
     p->fillRect(platformRect, QColor(color));
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::fillRect()");
 }
 
 void GraphicsContext::fillRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight, const Color& color, ColorSpace colorSpace)
@@ -929,6 +965,11 @@
     if (paintingDisabled() || !color.isValid())
         return;
 
+    QColor qcolor = QColor(color);
+    int r,g,b,a;
+    qcolor.getRgb(&r, &g, &b, &a);
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext::fillRoundedRect() %dx%d+%d+%d,%02X%02X%02X%02X", rect.width(), rect.height(), rect.x(), rect.y(), r, g, b, a);
+
     Path path;
     path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);
     QPainter* p = m_data->p();
@@ -951,6 +992,11 @@
     if (paintingDisabled() || !color.isValid())
         return;
 
+    QColor qcolor = QColor(color);
+    int r,g,b,a;
+    qcolor.getRgb(&r, &g, &b, &a);
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "GraphicsContext::fillRectWithRoundedHole() %dx%d+%d+%d,%02X%02X%02X%02X", rect.width(), rect.height(), rect.x(), rect.y(), r, g, b, a);
+
     Path path;
     path.addRect(rect);
     if (!roundedHoleRect.radii().isZero())
@@ -1346,11 +1392,20 @@
     if (paintingDisabled())
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsContext::clearRect() %dx%d+%d+%d", (int)rect.width(), (int)rect.height(), (int)rect.x(), (int)rect.y());
+
     QPainter* p = m_data->p();
     QPainter::CompositionMode currentCompositionMode = p->compositionMode();
     p->setCompositionMode(QPainter::CompositionMode_Source);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QPainter::fillRect() %gx%g+%g+%g,%s", rect.width(), rect.height(), rect.x(), rect.y(), "color");
+
     p->fillRect(rect, Qt::transparent);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-QPainter::fillRect()");
+
     p->setCompositionMode(currentCompositionMode);
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsContext::clearRect()");
 }
 
 void GraphicsContext::strokeRect(const FloatRect& rect, float lineWidth)
diff -Naur a/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp b/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp
--- a/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp	2016-04-13 13:51:22.547584700 -0700
+++ b/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -293,16 +293,22 @@
     painter->restore();
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x100)
+
 void ImageBufferDataPrivateAccelerated::paintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& matrix, float opacity)
 {
     if (textureMapper->accelerationMode() != TextureMapper::OpenGLMode) {
         return;
     }
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+ImageBufferDataPrivateAccelerated::paintToTextureMapper()");
+
     commitChanges();
 
     static_cast<TextureMapperGL*>(textureMapper)->drawTexture(m_fbo->texture(), TextureMapperGL::ShouldFlipTexture | TextureMapperGL::ShouldBlend, m_fbo->size(), targetRect, matrix, opacity);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-ImageBufferDataPrivateAccelerated::paintToTextureMapper()");
 }
 
 #endif // ACCELERATED_2D_CANVAS
diff -Naur a/Source/WebCore/platform/graphics/qt/ImageQt.cpp b/Source/WebCore/platform/graphics/qt/ImageQt.cpp
--- a/Source/WebCore/platform/graphics/qt/ImageQt.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/graphics/qt/ImageQt.cpp	2016-07-06 13:02:43.766445100 -0700
@@ -53,6 +53,9 @@
 
 #include <math.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x100)
+
 #if OS(WINDOWS)
 QT_BEGIN_NAMESPACE
 Q_GUI_EXPORT QPixmap qt_pixmapFromWinHBITMAP(HBITMAP, int hbitmapFormat = 0);
@@ -157,6 +160,8 @@
     if (transform.type() == QTransform::TxScale && transform.m11() == 0 && transform.m22() == 0)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+Image::drawPattern()");
+
     QPixmap pixmap = *framePixmap;
     if (tr.x() || tr.y() || tr.width() != pixmap.width() || tr.height() != pixmap.height())
         pixmap = pixmap.copy(tr);
@@ -194,10 +199,16 @@
 
     QBrush b(pixmap);
     b.setTransform(transform);
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QPainter::fillRect() %dx%d+%d+%d,%s", (int)dr.width(), (int)dr.height(), (int)dr.x(), (int)dr.y(), "pixmap");
+
     p->fillRect(dr, b);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-QPainter::fillRect()");
+
     ctxt->setCompositeOperation(previousOperator);
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-Image::drawPattern()");
+
     if (imageObserver())
         imageObserver()->didDraw(this);
 }
diff -Naur a/Source/WebCore/platform/graphics/surfaces/qt/GraphicsSurfaceEGL.cpp b/Source/WebCore/platform/graphics/surfaces/qt/GraphicsSurfaceEGL.cpp
--- a/Source/WebCore/platform/graphics/surfaces/qt/GraphicsSurfaceEGL.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/graphics/surfaces/qt/GraphicsSurfaceEGL.cpp	2016-07-06 13:02:43.770445100 -0700
@@ -522,11 +522,17 @@
         m_private->copyFromTexture(texture, sourceRect);
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x400)
 
 void GraphicsSurface::platformPaintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& transform, float opacity)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+GraphicsSurface::platformPaintToTextureMapper()");
+
     TextureMapperGL* texMapGL = static_cast<TextureMapperGL*>(textureMapper);
     texMapGL->drawTexture(platformGetTextureID(), TextureMapperGL::ShouldBlend, m_private->size(), targetRect, transform, opacity);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-GraphicsSurface::platformPaintToTextureMapper()");
 }
 
 uint32_t GraphicsSurface::platformFrontBuffer() const
diff -Naur a/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp b/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp
--- a/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp	2016-04-13 13:51:56.611880900 -0700
+++ b/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp	2016-07-06 13:02:43.770445100 -0700
@@ -67,6 +67,9 @@
 #define GL_UNPACK_SKIP_ROWS 0x0CF3
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x200)
+
 #if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER)
 
 namespace WebCore {
@@ -596,6 +599,8 @@
 
 void TextureMapperGL::drawTexture(Platform3DObject texture, Flags flags, const IntSize& textureSize, const FloatRect& targetRect, const TransformationMatrix& modelViewMatrix, float opacity, unsigned exposedEdges)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperGL::drawTexture()");
+
     bool useRect = flags & ShouldUseARBTextureRect;
     bool useAntialiasing = m_enableEdgeDistanceAntialiasing
         && exposedEdges == AllEdges
@@ -636,6 +641,8 @@
 #endif
 
     drawTexturedQuadWithProgram(program.get(), texture, flags, textureSize, targetRect, modelViewMatrix, opacity);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperGL::drawTexture()");
 }
 
 void TextureMapperGL::drawSolidColor(const FloatRect& rect, const TransformationMatrix& matrix, const Color& color)
@@ -731,6 +738,8 @@
 
 void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram* program, uint32_t texture, Flags flags, const IntSize& size, const FloatRect& rect, const TransformationMatrix& modelViewMatrix, float opacity)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperGL::drawTexturedQuadWithProgram()");
+
     m_context3D->useProgram(program->programID());
     m_context3D->activeTexture(GraphicsContext3D::TEXTURE0);
     GC3Denum target = flags & ShouldUseARBTextureRect ? GC3Denum(Extensions3D::TEXTURE_RECTANGLE_ARB) : GC3Denum(GraphicsContext3D::TEXTURE_2D);
@@ -758,6 +767,8 @@
     draw(rect, modelViewMatrix, program, GraphicsContext3D::TRIANGLE_FAN, flags);
     m_context3D->texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
     m_context3D->texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperGL::drawTexturedQuadWithProgram()");
 }
 
 BitmapTextureGL::BitmapTextureGL(TextureMapperGL* textureMapper)
diff -Naur a/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp b/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp
--- a/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp	2016-07-06 13:02:43.770445100 -0700
@@ -82,14 +82,21 @@
         sortByZOrder(m_children);
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x200)
+
 void TextureMapperLayer::paint()
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paint()");
+
     computeTransformsRecursive();
 
     TextureMapperPaintOptions options;
     options.textureMapper = m_textureMapper;
     options.textureMapper->bindSurface(0);
     paintRecursive(options);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paint()");
 }
 
 static Color blendWithOpacity(const Color& color, float opacity)
@@ -117,6 +124,8 @@
     if (!m_state.visible || !m_state.contentsVisible)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintSelf()");
+
     // We apply the following transform to compensate for painting into a surface, and then apply the offset so that the painting fits in the target rect.
     TransformationMatrix transform;
     transform.translate(options.offset.width(), options.offset.height());
@@ -127,6 +136,9 @@
         options.textureMapper->drawSolidColor(m_state.contentsRect, transform, blendWithOpacity(m_state.solidColor, options.opacity));
         if (m_state.showDebugBorders)
             options.textureMapper->drawBorder(m_state.debugBorderColor, m_state.debugBorderWidth, layerRect(), transform);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelf()");
+
         return;
     }
 
@@ -144,9 +156,12 @@
             m_backingStore->drawRepaintCounter(options.textureMapper, m_state.repaintCount, m_state.debugBorderColor, targetRect, transform);
     }
 
-    if (!m_contentsLayer)
-        return;
+    if (!m_contentsLayer) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelf()");
 
+        return;
+    }
     if (!m_state.contentsTileSize.isEmpty()) {
         computePatternTransformIfNeeded();
         options.textureMapper->setWrapMode(TextureMapper::RepeatWrap);
@@ -157,6 +172,8 @@
     m_contentsLayer->paintToTextureMapper(options.textureMapper, m_state.contentsRect, transform, options.opacity);
     if (m_state.showDebugBorders)
         m_contentsLayer->drawBorder(options.textureMapper, m_state.debugBorderColor, m_state.debugBorderWidth, m_state.contentsRect, transform);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelf()");
 }
 
 int TextureMapperLayer::compareGraphicsLayersZValue(const void* a, const void* b)
@@ -173,10 +190,16 @@
 
 void TextureMapperLayer::paintSelfAndChildren(const TextureMapperPaintOptions& options)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintSelfAndChildren() %d", m_children.size());
+
     paintSelf(options);
 
-    if (m_children.isEmpty())
+    if (m_children.isEmpty()) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelfAndChildren()");
+
         return;
+    }
 
     bool shouldClip = m_state.masksToBounds && !m_state.preserves3D;
     if (shouldClip) {
@@ -192,6 +215,8 @@
 
     if (shouldClip)
         options.textureMapper->endClip();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelfAndChildren()");
 }
 
 bool TextureMapperLayer::shouldBlend() const
@@ -220,6 +245,8 @@
 
 void TextureMapperLayer::paintSelfAndChildrenWithReplica(const TextureMapperPaintOptions& options)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintSelfAndChildrenWithReplica()");
+
     if (m_state.replicaLayer) {
         TextureMapperPaintOptions replicaOptions(options);
         replicaOptions.transform
@@ -229,6 +256,8 @@
     }
 
     paintSelfAndChildren(options);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintSelfAndChildrenWithReplica()");
 }
 
 void TextureMapperLayer::setAnimatedTransform(const TransformationMatrix& matrix)
@@ -330,8 +359,20 @@
     Region overlapRegion;
     Region nonOverlapRegion;
     computeOverlapRegions(overlapRegion, nonOverlapRegion, ResolveSelfOverlapAlways);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintUsingOverlapRegions()_%dx%d+%d+%d_%d %d %d",
+       options.textureMapper->clipBounds().width(), options.textureMapper->clipBounds().height(),
+       options.textureMapper->clipBounds().x(), options.textureMapper->clipBounds().y(), options.offset,
+       nonOverlapRegion.rects().size(), overlapRegion.rects().size());
+
     if (overlapRegion.isEmpty()) {
         paintSelfAndChildrenWithReplica(options);
+
+       if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintUsingOverlapRegions()_%dx%d+%d+%d_%d %d %d",
+          options.textureMapper->clipBounds().width(), options.textureMapper->clipBounds().height(),
+          options.textureMapper->clipBounds().x(), options.textureMapper->clipBounds().y(), options.offset,
+          nonOverlapRegion.rects().size(), overlapRegion.rects().size());
+
         return;
     }
 
@@ -347,10 +388,17 @@
 
     for (size_t i = 0; i < rects.size(); ++i) {
         IntRect rect = rects[i];
-        if (!rect.intersects(options.textureMapper->clipBounds()))
+        if (!rect.intersects(options.textureMapper->clipBounds())) {
+
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+overlaprect %d %d %d skip", i, rect.x(), rect.y());
+
             continue;
+        }
 
         options.textureMapper->beginClip(TransformationMatrix(), rects[i]);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+overlaprect %d %d %d paintSelfAndChildrenWithReplica", i, rect.x(), rect.y());
+
         paintSelfAndChildrenWithReplica(options);
         options.textureMapper->endClip();
     }
@@ -367,17 +415,31 @@
     adjustedClipBounds.move(-options.offset);
     for (size_t i = 0; i < rects.size(); ++i) {
         IntRect rect = rects[i];
+
         for (int x = rect.x(); x < rect.maxX(); x += maxTextureSize.width()) {
             for (int y = rect.y(); y < rect.maxY(); y += maxTextureSize.height()) {
+
                 IntRect tileRect(IntPoint(x, y), maxTextureSize);
                 tileRect.intersect(rect);
-                if (!tileRect.intersects(adjustedClipBounds))
-                    continue;
+                if (!tileRect.intersects(adjustedClipBounds)) {
+
+                   if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+overlaprect %d %d %d skip", i, rect.x(), rect.y());
+
+                   continue;
+                }
+
+                if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+overlaprect %d %d %d paintWithIntermediateSurface", i, rect.x(), rect.y());
 
                 paintWithIntermediateSurface(options, tileRect);
             }
         }
     }
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintUsingOverlapRegions()_%dx%d+%d+%d_%d %d %d",
+       options.textureMapper->clipBounds().width(), options.textureMapper->clipBounds().height(),
+       options.textureMapper->clipBounds().x(), options.textureMapper->clipBounds().y(), options.offset,
+       nonOverlapRegion.rects().size(), overlapRegion.rects().size());
+
 }
 
 void TextureMapperLayer::applyMask(const TextureMapperPaintOptions& options)
@@ -414,6 +476,8 @@
 
 void TextureMapperLayer::paintWithIntermediateSurface(const TextureMapperPaintOptions& options, const IntRect& rect)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintWithIntermediateSurface() %dx%d+%d+%d", rect.width(), rect.height(), rect.x(), rect.y());
+
     RefPtr<BitmapTexture> replicaSurface;
     RefPtr<BitmapTexture> mainSurface;
     TextureMapperPaintOptions paintOptions(options);
@@ -441,22 +505,34 @@
     }
 
     commitSurface(options, mainSurface, rect, options.opacity);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintWithIntermediateSurface()");
 }
 
 void TextureMapperLayer::paintRecursive(const TextureMapperPaintOptions& options)
 {
-    if (!isVisible())
-        return;
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::paintRecursive()");
+
+    if (!isVisible()) {
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintRecursive()");
+
+        return;
+    }
     TextureMapperPaintOptions paintOptions(options);
     paintOptions.opacity *= m_currentOpacity;
 
     if (!shouldBlend()) {
         paintSelfAndChildrenWithReplica(paintOptions);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintRecursive()");
+
         return;
     }
 
     paintUsingOverlapRegions(paintOptions);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::paintRecursive()");
 }
 
 TextureMapperLayer::~TextureMapperLayer()
@@ -686,6 +762,8 @@
 
 void TextureMapperLayer::syncAnimations()
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayer::syncAnimations()");
+
     m_animations.apply(this);
     if (!m_animations.hasActiveAnimationsOfType(AnimatedPropertyWebkitTransform))
         m_currentTransform.setLocalTransform(m_state.transform);
@@ -696,6 +774,8 @@
     if (!m_animations.hasActiveAnimationsOfType(AnimatedPropertyWebkitFilter))
         m_currentFilters = m_state.filters;
 #endif
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayer::syncAnimations()");
 }
 
 bool TextureMapperLayer::isAncestorFixedToViewport() const
diff -Naur a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp
--- a/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp	2015-05-27 11:10:00.978317900 -0700
+++ b/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp	2016-07-06 13:02:43.770445100 -0700
@@ -42,6 +42,9 @@
 #include "PlatformInstrumentation.h"
 #include <wtf/PassOwnPtr.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x40)
+
 extern "C" {
 #if USE(ICCJPEG)
 #include "iccjpeg.h"
@@ -622,7 +625,13 @@
     ImageFrame& frame = m_frameBufferCache[0];
     if (frame.status() != ImageFrame::FrameComplete) {
         PlatformInstrumentation::willDecodeImage("JPEG");
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+JPEGImageDecoder::frameBufferAtIndex()");
+
         decode(false);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-JPEGImageDecoder::frameBufferAtIndex()");
+
         PlatformInstrumentation::didDecodeImage();
     }
     return &frame;
diff -Naur a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp
--- a/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp	2015-05-27 11:10:00.994317900 -0700
+++ b/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp	2016-07-06 13:02:43.770445100 -0700
@@ -50,6 +50,9 @@
 #include "qcms.h"
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x40)
+
 #if defined(PNG_LIBPNG_VER_MAJOR) && defined(PNG_LIBPNG_VER_MINOR) && (PNG_LIBPNG_VER_MAJOR > 1 || (PNG_LIBPNG_VER_MAJOR == 1 && PNG_LIBPNG_VER_MINOR >= 4))
 #define JMPBUF(png_ptr) png_jmpbuf(png_ptr)
 #else
@@ -259,7 +262,13 @@
     ImageFrame& frame = m_frameBufferCache[0];
     if (frame.status() != ImageFrame::FrameComplete) {
         PlatformInstrumentation::willDecodeImage("PNG");
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+PNGImageDecoder::frameBufferAtIndex()");
+
         decode(false);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-PNGImageDecoder::frameBufferAtIndex()");
+
         PlatformInstrumentation::didDecodeImage();
     }
     return &frame;
diff -Naur a/Source/WebCore/platform/text/TextCodecUTF8.cpp b/Source/WebCore/platform/text/TextCodecUTF8.cpp
--- a/Source/WebCore/platform/text/TextCodecUTF8.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WebCore/platform/text/TextCodecUTF8.cpp	2016-07-11 15:36:04.010925539 -0700
@@ -260,12 +260,31 @@
 
     return false;
 }
-    
+
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x1000)
+#define MAXSTRLEN 64
+#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
+
+
 String TextCodecUTF8::decode(const char* bytes, size_t length, bool flush, bool stopOnError, bool& sawError)
 {
+    if ((tditrace_ex != NULL) && bytes) {
+      unsigned int ra = 0;
+      #ifdef __mips__
+      asm volatile("move %0, $ra" : "=r"(ra));
+      #endif
+      char s[MAXSTRLEN + 1];
+      strncpy(s, (const char*)bytes, MIN(MAXSTRLEN, length));
+      s[MIN(MAXSTRLEN, length)] = '\0';
+      tditrace_ex(TDIMASK, "@S+TextCodecUTF8::decode() %d [%s]%n", length, s, ra);
+      tditrace_ex(TDIMASK, "@A+TextCodecUTF8::decode() %d", length);
+    }
+
     // Each input byte might turn into a character.
     // That includes all bytes in the partial-sequence buffer because
     // each byte in an invalid sequence will turn into a replacement character.
+
     StringBuffer<LChar> buffer(m_partialSequenceSize + length);
 
     const uint8_t* source = reinterpret_cast<const uint8_t*>(bytes);
@@ -342,9 +361,14 @@
 
     buffer.shrink(destination - buffer.characters());
 
+    if ((tditrace_ex != NULL) && bytes) tditrace_ex(TDIMASK, "@A-TextCodecUTF8::decode()");
+
     return String::adopt(buffer);
 
 upConvertTo16Bit:
+    
+    if ((tditrace_ex != NULL) && bytes) tditrace_ex(TDIMASK, "@A+TextCodecUTF8::decode()16 %d", length);
+
     StringBuffer<UChar> buffer16(m_partialSequenceSize + length);
 
     UChar* destination16 = buffer16.characters();
@@ -417,6 +441,9 @@
     } while (flush && m_partialSequenceSize);
     
     buffer16.shrink(destination16 - buffer16.characters());
+
+    if ((tditrace_ex != NULL) && bytes) tditrace_ex(TDIMASK, "@A-TextCodecUTF8::decode()16");
+    if ((tditrace_ex != NULL) && bytes) tditrace_ex(TDIMASK, "@A-TextCodecUTF8::decode()");
     
     return String::adopt(buffer16);
 }
diff -Naur a/Source/WebCore/rendering/RenderBlock.cpp b/Source/WebCore/rendering/RenderBlock.cpp
--- a/Source/WebCore/rendering/RenderBlock.cpp	2015-05-27 11:10:00.994317900 -0700
+++ b/Source/WebCore/rendering/RenderBlock.cpp	2016-07-06 13:02:43.786445100 -0700
@@ -65,11 +65,15 @@
 #include <wtf/StackStats.h>
 #include <wtf/TemporaryChange.h>
 
+
 #if ENABLE(CSS_SHAPES)
 #include "ShapeInsideInfo.h"
 #include "ShapeOutsideInfo.h"
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2)
+
 using namespace std;
 using namespace WTF;
 using namespace Unicode;
@@ -2970,6 +2974,44 @@
  
 void RenderBlock::paint(PaintInfo& paintInfo, const LayoutPoint& paintOffset)
 {
+    if (tditrace_ex != NULL) {
+        StringBuilder name;
+        if (Element* element = node() && node()->isElementNode() ? toElement(node()) : 0) {
+            name.append(element->tagName());
+
+            if (element->hasID()) {
+                name.appendLiteral(" id=\'");
+                name.append(element->getIdAttribute());
+                name.append('\'');
+            }
+
+            if (element->hasClass()) {
+                name.appendLiteral(" class=\'");
+                for (size_t i = 0; i < element->classNames().size(); ++i) {
+                    if (i > 0)
+                        name.append(' ');
+                    name.append(element->classNames()[i]);
+                }
+                name.append('\'');
+            }
+        }
+
+        char text[256];
+        int i;
+        if (name.toString().is8Bit()) {
+            i = name.toString().length() < 255 ? name.toString().length() : 255;
+            strncpy(text, (char*)name.toString().characters8(), i);
+        } else {
+            char* p = (char*)name.toString().characters8();
+            for (i = 0 ; i < (name.toString().length() < 255 ? name.toString().length() : 255) ; i++) {
+                text[i] = p[i];
+            }
+        }
+        text[i]=0;
+        tditrace_ex(TDIMASK, "@S+RenderBlock::paint() %s,%dx%d+%d+%d,+%d+%d", text, paintInfo.rect.width(), paintInfo.rect.height(), paintInfo.rect.x(), paintInfo.rect.y(), paintOffset.x().toInt(), paintOffset.y().toInt());
+        tditrace_ex(TDIMASK, "@T+RenderBlock::paint()");
+    }
+
     LayoutPoint adjustedPaintOffset = paintOffset + location();
     
     PaintPhase phase = paintInfo.phase;
@@ -2982,8 +3024,11 @@
         flipForWritingMode(overflowBox);
         overflowBox.inflate(maximalOutlineSize(paintInfo.phase));
         overflowBox.moveBy(adjustedPaintOffset);
-        if (!overflowBox.intersects(paintInfo.rect))
+        if (!overflowBox.intersects(paintInfo.rect)) {
+
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderBlock::paint()");
             return;
+        }
     }
 
     bool pushedClip = pushContentsClip(paintInfo, adjustedPaintOffset);
@@ -2996,6 +3041,8 @@
     // sit above the background/border.
     if (hasOverflowClip() && style()->visibility() == VISIBLE && (phase == PaintPhaseBlockBackground || phase == PaintPhaseChildBlockBackground) && paintInfo.shouldPaintWithinRoot(this) && !paintInfo.paintRootBackgroundOnly())
         layer()->paintOverflowControls(paintInfo.context, roundedIntPoint(adjustedPaintOffset), paintInfo.rect);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderBlock::paint()");
 }
 
 void RenderBlock::paintColumnRules(PaintInfo& paintInfo, const LayoutPoint& paintOffset)
diff -Naur a/Source/WebCore/rendering/RenderBox.cpp b/Source/WebCore/rendering/RenderBox.cpp
--- a/Source/WebCore/rendering/RenderBox.cpp	2015-05-27 11:10:00.998317900 -0700
+++ b/Source/WebCore/rendering/RenderBox.cpp	2016-07-06 13:02:43.786445100 -0700
@@ -61,6 +61,9 @@
 #include "RenderLayerCompositor.h"
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2)
+
 using namespace std;
 
 namespace WebCore {
@@ -1039,6 +1042,8 @@
 
 void RenderBox::paint(PaintInfo& paintInfo, const LayoutPoint& paintOffset)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderBox::paint()");
+
     LayoutPoint adjustedPaintOffset = paintOffset + location();
     // default implementation. Just pass paint through to the children
     PaintInfo childInfo(paintInfo);
@@ -1100,6 +1105,8 @@
     if (!paintInfo.shouldPaintWithinRoot(this))
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+RenderBox::paintBoxDecorations()");
+
     LayoutRect paintRect = borderBoxRectInRegion(paintInfo.renderRegion);
     paintRect.moveBy(paintOffset);
 
@@ -1142,19 +1149,31 @@
 
     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
         paintInfo.context->endTransparencyLayer();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderBox::paintBoxDecorations()");
 }
 
 void RenderBox::paintBackground(const PaintInfo& paintInfo, const LayoutRect& paintRect, BackgroundBleedAvoidance bleedAvoidance)
 {
     if (isRoot()) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+RenderBox::paintBackground()");
+
         paintRootBoxFillLayers(paintInfo);
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderBox::paintBackground()");
         return;
     }
     if (isBody() && skipBodyBackground(this))
         return;
     if (backgroundIsKnownToBeObscured() && !boxShadowShouldBeAppliedToBackground(bleedAvoidance))
         return;
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+RenderBox::paintBackground()");
+
     paintFillLayers(paintInfo, style()->visitedDependentColor(CSSPropertyBackgroundColor), style()->backgroundLayers(), paintRect, bleedAvoidance);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderBox::paintBackground()");
 }
 
 bool RenderBox::getBackgroundPaintedExtent(LayoutRect& paintedExtent) const
diff -Naur a/Source/WebCore/rendering/RenderImage.cpp b/Source/WebCore/rendering/RenderImage.cpp
--- a/Source/WebCore/rendering/RenderImage.cpp	2015-05-27 11:10:00.998317900 -0700
+++ b/Source/WebCore/rendering/RenderImage.cpp	2016-07-06 13:02:43.786445100 -0700
@@ -47,6 +47,9 @@
 #include "SVGImage.h"
 #include <wtf/StackStats.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2)
+
 using namespace std;
 
 namespace WebCore {
@@ -408,6 +411,8 @@
 
 void RenderImage::paint(PaintInfo& paintInfo, const LayoutPoint& paintOffset)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderImage::paint() %dx%d+%d+%d,+%d+%d", paintInfo.rect.width(), paintInfo.rect.height(), paintInfo.rect.x(), paintInfo.rect.y(), paintOffset.x().toInt(), paintOffset.y().toInt());
+
     RenderReplaced::paint(paintInfo, paintOffset);
     
     if (paintInfo.phase == PaintPhaseOutline)
diff -Naur a/Source/WebCore/rendering/RenderLayerBacking.cpp b/Source/WebCore/rendering/RenderLayerBacking.cpp
--- a/Source/WebCore/rendering/RenderLayerBacking.cpp	2015-05-27 11:10:00.998317900 -0700
+++ b/Source/WebCore/rendering/RenderLayerBacking.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -2009,6 +2009,9 @@
     context.restore();
 }
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x4)
+
 // Up-call from compositing layer drawing callback.
 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext& context, GraphicsLayerPaintingPhase paintingPhase, const IntRect& clip)
 {
@@ -2024,6 +2027,8 @@
         || graphicsLayer == m_scrollingContentsLayer.get()) {
         InspectorInstrumentation::willPaint(renderer());
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+RenderLayerBacking::paintContents()");
+
         // The dirtyRect is in the coords of the painting root.
         IntRect dirtyRect = clip;
         if (!(paintingPhase & GraphicsLayerPaintOverflowContents))
@@ -2032,6 +2037,8 @@
         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
         paintIntoLayer(graphicsLayer, &context, dirtyRect, PaintBehaviorNormal, paintingPhase);
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayerBacking::paintContents()");
+
         InspectorInstrumentation::didPaint(renderer(), &context, clip);
     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
         paintScrollbar(m_owningLayer->horizontalScrollbar(), context, clip);
@@ -2171,6 +2178,9 @@
     ASSERT(property != CSSPropertyInvalid);
 
     if (property == CSSPropertyOpacity) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderLayerBacking::startTransition() CSSPropertyOpacity");
+
         const Animation* opacityAnim = toStyle->transitionForProperty(CSSPropertyOpacity);
         if (opacityAnim && !opacityAnim->isEmptyOrZeroDuration()) {
             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
@@ -2186,6 +2196,9 @@
     }
 
     if (property == CSSPropertyWebkitTransform && m_owningLayer->hasTransform()) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderLayerBacking::startTransition() CSSPropertyWebkitTransform");
+
         const Animation* transformAnim = toStyle->transitionForProperty(CSSPropertyWebkitTransform);
         if (transformAnim && !transformAnim->isEmptyOrZeroDuration()) {
             KeyframeValueList transformVector(AnimatedPropertyWebkitTransform);
@@ -2201,6 +2214,9 @@
 
 #if ENABLE(CSS_FILTERS)
     if (property == CSSPropertyWebkitFilter && m_owningLayer->hasFilter()) {
+
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderLayerBacking::startTransition() CSSPropertyWebkitFilter");
+
         const Animation* filterAnim = toStyle->transitionForProperty(CSSPropertyWebkitFilter);
         if (filterAnim && !filterAnim->isEmptyOrZeroDuration()) {
             KeyframeValueList filterVector(AnimatedPropertyWebkitFilter);
@@ -2220,6 +2236,8 @@
 
 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderLayerBacking::transitionPaused()");
+
     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
     if (animatedProperty != AnimatedPropertyInvalid)
         m_graphicsLayer->pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
@@ -2227,6 +2245,8 @@
 
 void RenderLayerBacking::transitionFinished(CSSPropertyID property)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderLayerBacking::transitionFinished()");
+
     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
     if (animatedProperty != AnimatedPropertyInvalid)
         m_graphicsLayer->removeAnimation(GraphicsLayer::animationNameForTransition(animatedProperty));
diff -Naur a/Source/WebCore/rendering/RenderLayer.cpp b/Source/WebCore/rendering/RenderLayer.cpp
--- a/Source/WebCore/rendering/RenderLayer.cpp	2015-05-27 11:10:00.998317900 -0700
+++ b/Source/WebCore/rendering/RenderLayer.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -126,6 +126,9 @@
 #include "ValidatedCustomFilterOperation.h"
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2)
+
 #define MIN_INTERSECT_FOR_REVEAL 32
 
 using namespace std;
@@ -3605,6 +3608,26 @@
 
 void RenderLayer::paintLayer(GraphicsContext* context, const LayerPaintingInfo& paintingInfo, PaintLayerFlags paintFlags)
 {
+    if (tditrace_ex != NULL) {
+        char text[256];
+        int i;
+        if (name().is8Bit()) {
+            i = name().length() < 255 ? name().length() : 255;
+            strncpy(text, (char*)name().characters8(), i);
+        } else {
+            char* p = (char*)name().characters8();
+            for (i = 0 ; i < (name().length() < 255 ? name().length() : 255) ; i++) {
+                text[i] = p[i];
+            }
+        }
+        text[i]=0;
+        tditrace_ex(TDIMASK, "@S+RenderLayer::paintLayer() %s %dx%d+%d+%d", text,
+            paintingInfo.paintDirtyRect.width().toInt(),
+            paintingInfo.paintDirtyRect.height().toInt(),
+            paintingInfo.paintDirtyRect.x().toInt(),
+            paintingInfo.paintDirtyRect.y().toInt());
+    }
+
 #if USE(ACCELERATED_COMPOSITING)
     if (isComposited()) {
         // The updatingControlTints() painting pass goes through compositing layers,
@@ -3616,26 +3639,34 @@
             && !shouldDoSoftwarePaint(this, paintFlags & PaintLayerPaintingReflection)
             && !paintForFixedRootBackground(this, paintFlags)) {
             // If this RenderLayer should paint into its backing, that will be done via RenderLayerBacking::paintIntoLayer().
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
             return;
         }
     } else if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {
         // Don't paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
         // unless their position or viewport size is changed.
         ASSERT(renderer()->style()->position() == FixedPosition);
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
         return;
     }
 #endif
 
     // Non self-painting leaf layers don't need to be painted as their renderer() should properly paint itself.
-    if (!isSelfPaintingLayer() && !hasSelfPaintingLayerDescendant())
+    if (!isSelfPaintingLayer() && !hasSelfPaintingLayerDescendant()) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
         return;
+    }
 
-    if (shouldSuppressPaintingLayer(this))
+    if (shouldSuppressPaintingLayer(this)) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
         return;
+    }
     
     // If this layer is totally invisible then there is nothing to paint.
-    if (!renderer()->opacity())
+    if (!renderer()->opacity()) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
         return;
+    }
 
     if (paintsWithTransparency(paintingInfo.paintBehavior))
         paintFlags |= PaintLayerHaveTransparency;
@@ -3644,8 +3675,10 @@
     if (paintsWithTransform(paintingInfo.paintBehavior) && !(paintFlags & PaintLayerAppliedTransform)) {
         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
         // If the transform can't be inverted, then don't paint anything.
-        if (!layerTransform.isInvertible())
+        if (!layerTransform.isInvertible()) {
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
             return;
+        }
 
         // If we have a transparency layer enclosing us and we are the root of a transform, then we need to establish the transparency
         // layer from the parent now, assuming there is a parent
@@ -3658,6 +3691,7 @@
 
         if (enclosingPaginationLayer()) {
             paintTransformedLayerIntoFragments(context, paintingInfo, paintFlags);
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
             return;
         }
 
@@ -3679,10 +3713,13 @@
         if (parent())
             parent()->restoreClip(context, paintingInfo.paintDirtyRect, clipRect);
 
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
         return;
     }
     
     paintLayerContentsAndReflection(context, paintingInfo, paintFlags);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-RenderLayer::paintLayer()");
 }
 
 void RenderLayer::paintLayerContentsAndReflection(GraphicsContext* context, const LayerPaintingInfo& paintingInfo, PaintLayerFlags paintFlags)
diff -Naur a/Source/WebCore/rendering/RenderVideo.cpp b/Source/WebCore/rendering/RenderVideo.cpp
--- a/Source/WebCore/rendering/RenderVideo.cpp	2015-05-27 11:10:00.998317900 -0700
+++ b/Source/WebCore/rendering/RenderVideo.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -44,6 +44,9 @@
 #include "RenderFullScreen.h"
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x2)
+
 namespace WebCore {
 
 using namespace HTMLNames;
@@ -192,6 +195,8 @@
     MediaPlayer* mediaPlayer = mediaElement()->player();
     bool displayingPoster = videoElement()->shouldDisplayPosterImage();
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@S+RenderVideo::paintReplaced() %dx%d+%d+%d,+%d+%d", paintInfo.rect.width(), paintInfo.rect.height(), paintInfo.rect.x(), paintInfo.rect.y(), paintOffset.x().toInt(), paintOffset.y().toInt());
+
     Page* page = 0;
     if (Frame* frame = this->frame())
         page = frame->page();
diff -Naur a/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp b/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp
--- a/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp	2015-06-05 16:52:24.994936700 -0700
+++ b/Source/WebKit/qt/WebCoreSupport/QWebFrameAdapter.cpp	2016-07-11 16:40:30.206906524 -0700
@@ -65,6 +65,9 @@
 #include <QFileInfo>
 #include <QNetworkRequest>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x800)
+
 using namespace WebCore;
 
 static inline ResourceRequestCachePolicy cacheLoadControlToCachePolicy(uint cacheLoadControl)
@@ -508,6 +511,9 @@
     if (vector.isEmpty())
         return;
 
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QWebFrameAdapter::renderRelativeCoords()");
+
     WebCore::FrameView* view = frame->view();
     view->updateLayoutAndStyleIfNeededRecursive();
 
@@ -550,6 +556,8 @@
         context.restore();
     }
 #endif
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-QWebFrameAdapter::renderRelativeCoords()");
 }
 
 void QWebFrameAdapter::renderFrameExtras(WebCore::GraphicsContext* context, int layers, const QRegion& clip)
diff -Naur a/Source/WebKit/qt/WebCoreSupport/TextureMapperLayerClientQt.cpp b/Source/WebKit/qt/WebCoreSupport/TextureMapperLayerClientQt.cpp
--- a/Source/WebKit/qt/WebCoreSupport/TextureMapperLayerClientQt.cpp	2015-06-05 17:28:16.859913100 -0700
+++ b/Source/WebKit/qt/WebCoreSupport/TextureMapperLayerClientQt.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -22,6 +22,9 @@
 #include "config.h"
 #include "TextureMapperLayerClientQt.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x200)
+
 #if USE(ACCELERATED_COMPOSITING)
 
 #include "FrameView.h"
@@ -84,18 +87,25 @@
 
 void TextureMapperLayerClientQt::syncLayers(Timer<TextureMapperLayerClientQt>*)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayerClientQt::syncLayers()");
+
+
     if (m_rootGraphicsLayer)
         syncRootLayer();
 
     m_frame->frame->view()->flushCompositingStateIncludingSubframes();
 
-    if (!m_rootGraphicsLayer)
+    if (!m_rootGraphicsLayer) {
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "TextureMapperLayerClientQt::syncLayers()");
         return;
+    }
 
     if (rootLayer()->descendantsOrSelfHaveRunningAnimations() && !m_syncTimer.isActive())
         m_syncTimer.startOneShot(1.0 / 70.0);
 
     m_frame->pageAdapter->client->repaintViewport();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayerClientQt::syncLayers()");
 }
 
 void TextureMapperLayerClientQt::renderCompositedLayers(GraphicsContext* context, const IntRect& clip)
@@ -103,6 +113,8 @@
     if (!m_rootTextureMapperLayer || !m_textureMapper)
         return;
 
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+TextureMapperLayerClientQt::renderCompositedLayers()");
+
     m_textureMapper->setGraphicsContext(context);
     // GraphicsContext::imageInterpolationQuality is always InterpolationDefault here,
     // but 'default' may be interpreted differently due to a different backend QPainter,
@@ -141,6 +153,8 @@
     m_fpsCounter.updateFPSAndDisplay(m_textureMapper.get(), IntPoint::zero(), matrix);
     m_textureMapper->endClip();
     m_textureMapper->endPainting();
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-TextureMapperLayerClientQt::renderCompositedLayers()");
 }
 
 #endif
diff -Naur a/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp b/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp
--- a/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp	2015-06-05 17:28:50.419309800 -0700
+++ b/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -43,6 +43,9 @@
 #include <QX11Info>
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x800)
+
 using namespace WebCore;
 
 class QGraphicsWebViewPrivate {
@@ -242,6 +245,8 @@
 */
 void QGraphicsWebView::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget*)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QGraphicsWebView::paint()");
+
 #ifndef QT_NO_OPENGL
     d->page->d->saveGLContext();
 #endif
@@ -252,11 +257,14 @@
     // QWebFrame::render is a public API, bypass it for tiled rendering so behavior does not need to change.
     if (page()->mainFrame()->d->renderFromTiledBackingStore(painter, option->exposedRect.toAlignedRect())) {
         painter->setRenderHints(oldHints);
+        if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QGraphicsWebView::paint()");
         return;
     }
 #endif
     page()->mainFrame()->render(painter, QWebFrame::AllLayers, option->exposedRect.toRect());
     painter->setRenderHints(oldHints);
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-QGraphicsWebView::paint()");
 }
 
 /*! \reimp
diff -Naur a/Source/WebKit/qt/WidgetApi/qwebframe.cpp b/Source/WebKit/qt/WidgetApi/qwebframe.cpp
--- a/Source/WebKit/qt/WidgetApi/qwebframe.cpp	2015-06-05 17:29:20.608189300 -0700
+++ b/Source/WebKit/qt/WidgetApi/qwebframe.cpp	2016-07-06 13:02:43.790445100 -0700
@@ -41,6 +41,10 @@
 #include <qnetworkrequest.h>
 #include <qregion.h>
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x800)
+
+
 using namespace WebCore;
 
 // from text/qfont.cpp
@@ -640,10 +644,14 @@
 
 void QWebFrame::render(QPainter* painter, RenderLayers layer, const QRegion& clip)
 {
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T+QWebFrame::render()");
+
     if (!clip.isEmpty())
         d->renderRelativeCoords(painter, layer, clip);
     else if (d->hasView())
         d->renderRelativeCoords(painter, layer, QRegion(d->frameRect()));
+
+    if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "@T-QWebFrame::render()");
 }
 
 /*!
diff -Naur a/Source/WTF/wtf/FastMalloc.cpp b/Source/WTF/wtf/FastMalloc.cpp
--- a/Source/WTF/wtf/FastMalloc.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WTF/wtf/FastMalloc.cpp	2016-07-11 15:36:50.522548205 -0700
@@ -117,6 +117,9 @@
 #define USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY 1
 #endif
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x4000)
+
 #ifndef NDEBUG
 namespace WTF {
 
@@ -4176,6 +4179,17 @@
 
 void* fastMalloc(size_t size)
 {
+
+    if (tditrace_ex != NULL) {
+        if (size > 32 * 1024) {
+            unsigned int ra = 0;
+            #ifdef __mips__
+            asm volatile("move %0, $ra" : "=r"(ra));
+            #endif
+            tditrace_ex(TDIMASK, "fm%n%n", ra, size);
+        }
+    }
+
     return malloc<true>(size);
 }
 
@@ -4241,6 +4255,17 @@
 
 void* fastCalloc(size_t n, size_t elem_size)
 {
+
+    if (tditrace_ex != NULL) {
+        if ((n * elem_size) > 32 * 1024) {
+            unsigned int ra = 0;
+            #ifdef __mips__
+            asm volatile("move %0, $ra" : "=r"(ra));
+            #endif
+            tditrace_ex(TDIMASK, "fc%n%n", ra, n * elem_size);
+        }
+    }
+
     void* result = calloc<true>(n, elem_size);
 #if ENABLE(WTF_MALLOC_VALIDATION)
     fastMallocValidate(result);
@@ -4308,6 +4333,17 @@
 
 void* fastRealloc(void* old_ptr, size_t new_size)
 {
+
+    if (tditrace_ex != NULL) {
+        if (new_size > 32 * 1024) {
+            unsigned int ra = 0;
+            #ifdef __mips__
+            asm volatile("move %0, $ra" : "=r"(ra));
+            #endif
+            if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "fr%n%n", ra, new_size);
+        }
+    }
+
 #if ENABLE(WTF_MALLOC_VALIDATION)
     fastMallocValidate(old_ptr);
 #endif
diff -Naur a/Source/WTF/wtf/OSAllocatorPosix.cpp b/Source/WTF/wtf/OSAllocatorPosix.cpp
--- a/Source/WTF/wtf/OSAllocatorPosix.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WTF/wtf/OSAllocatorPosix.cpp	2016-07-11 15:37:13.025314398 -0700
@@ -44,8 +44,20 @@
 }
 #endif // CPU(MIPS)
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x4000)
+
 void* OSAllocator::reserveUncommitted(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
 {
+
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "ru%n%n", ra, bytes);
+    }
+
 #if OS(QNX)
     UNUSED_PARAM(usage);
     UNUSED_PARAM(writable);
@@ -108,6 +120,15 @@
 
 void* OSAllocator::reserveAndCommit(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
 {
+
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "rc%n%n", ra, bytes);
+    }
+
     // All POSIX reservations start out logically committed.
     int protection = PROT_READ;
     if (writable)
@@ -224,6 +245,14 @@
 
 void OSAllocator::releaseDecommitted(void* address, size_t bytes)
 {
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "rd%n%n", ra, bytes);
+    }
+
     int result = munmap(address, bytes);
     if (result == -1)
         CRASH();
diff -Naur a/Source/WTF/wtf/PageAllocationAligned.cpp b/Source/WTF/wtf/PageAllocationAligned.cpp
--- a/Source/WTF/wtf/PageAllocationAligned.cpp	2016-07-06 13:02:43.722445100 -0700
+++ b/Source/WTF/wtf/PageAllocationAligned.cpp	2016-07-11 15:37:24.540800166 -0700
@@ -26,10 +26,22 @@
 #include "config.h"
 #include "PageAllocationAligned.h"
 
+extern "C" void tditrace_ex(int mask, const char* format, ...) __attribute__((weak));
+#define TDIMASK (0x4000)
+
 namespace WTF {
 
 PageAllocationAligned PageAllocationAligned::allocate(size_t size, size_t alignment, OSAllocator::Usage usage, bool writable)
 {
+
+    if (tditrace_ex != NULL) {
+        unsigned int ra = 0;
+        #ifdef __mips__
+        asm volatile("move %0, $ra" : "=r"(ra));
+        #endif
+        tditrace_ex(TDIMASK, "pa%n%n", ra, size);
+    }
+
     ASSERT(isPageAligned(size));
     ASSERT(isPageAligned(alignment));
     ASSERT(isPowerOfTwo(alignment));
