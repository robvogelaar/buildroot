--- a/rockford/middleware/v3d/vcfw/rtos/rtos_abstract_mem.c	2016-02-18 20:06:27.598912025 -0800
+++ b/rockford/middleware/v3d/vcfw/rtos/abstract/rtos_abstract_mem.c	2016-02-19 12:44:04.871545966 -0800
@@ -710,6 +710,10 @@
    - MEM_HANDLE_INVALID is returned.
 */
 
+extern void tditrace_ex(const char* format, ...) __attribute__((weak));
+#define TDIMASK (1<<17|1<<0)
+#include <malloc.h>
+
 MEM_HANDLE_T mem_alloc_ex(
    uint32_t size,
    uint32_t align,
@@ -721,6 +725,26 @@
 
    UNUSED(mode);
 
+   if (tditrace_ex != NULL) {
+      unsigned int ra = 0;
+      #ifdef __mips__
+      asm volatile("move %0, $ra" : "=r"(ra));
+      #endif
+      char text[256];
+      int i;
+      strcpy(text, desc);
+      for (i = 0; i < strlen(text); i++) {
+         if (text[i] == ' ') text[i] = '_';
+      }
+      if (flags & MEM_FLAG_DIRECT) {
+         tditrace_ex(TDIMASK, "@E+gpu_mem_alloc %s %d ra=%x", text, size, ra);
+         tditrace_ex(TDIMASK, "gpu_mem_alloc~%d", size);
+      } else {
+         //tditrace_ex(TDIMASK, "@E+gpu_mem_alloc() %s %d ra=%x", text, size, ra);
+         tditrace_ex(TDIMASK, "gpu_mem_alloc*~%d", size);
+      }
+   }
+
    assert(is_power_of_2(align));
    assert(!(flags & ~MEM_FLAG_ALL));
    assert((flags & MEM_FLAG_RESIZEABLE) || !(flags & MEM_FLAG_HINT_GROW));
@@ -740,6 +764,26 @@
    }
 
    init_header(h, size, align, flags, desc);
+
+   if (tditrace_ex != NULL) {
+      char text[256];
+      int i;
+      strcpy(text, desc);
+      for (i = 0; i < strlen(text); i++) {
+         if (text[i] == ' ') text[i] = '_';
+      }
+      if (flags & MEM_FLAG_DIRECT) {
+          tditrace_ex(TDIMASK, "gpu_free~%d", g_mgr.memInterface->GetInfo(g_mgr.memInterface->context, BEGL_MemFree));
+      } else {
+          struct mallinfo mi;
+          mi = mallinfo();
+          tditrace_ex(TDIMASK, "gpu_mi.arena~%d", mi.arena);
+      }
+      if (h->ptr == NULL) {
+         tditrace_ex(TDIMASK, "@E+gpu_mem_alloc_fail %s %d", text, size);
+      }
+   }
+
    if ((h->size > 0) && (h->ptr == NULL))
    {
       free(h);
@@ -824,6 +868,18 @@
    /* put me back in if things start to go wrong */
    /*assert((handle != MEM_ZERO_SIZE_HANDLE) && (handle != MEM_EMPTY_STRING_HANDLE));*/
 
+   if (tditrace_ex != NULL) {
+      unsigned int ra = 0;
+      #ifdef __mips__
+      asm volatile("move %0, $ra" : "=r"(ra));
+      #endif
+      if (h->flags & MEM_FLAG_DIRECT) {
+         tditrace_ex(TDIMASK, "@E+gpu_mem_release ra=%x", ra);
+      } else {
+         //tditrace_ex(TDIMASK, "@E+gpu_mem_release* ra=%x", ra);
+      }
+   }
+
    if (h->term)
       h->term(h->ptr, h->size);
 
@@ -845,6 +901,16 @@
       }
    }
    free(h);
+
+   if (tditrace_ex != NULL) {
+      if (h->flags & MEM_FLAG_DIRECT) {
+         if (tditrace_ex != NULL) tditrace_ex(TDIMASK, "gpu_free~%d", g_mgr.memInterface->GetInfo(g_mgr.memInterface->context, BEGL_MemFree));
+      } else {
+         struct mallinfo mi;
+         mi = mallinfo();
+         tditrace_ex(TDIMASK, "gpu_mi.arena~%d", mi.arena);
+      }
+   }
 }
 
 /*
@@ -1120,6 +1186,19 @@
 
    UNUSED(mode);
 
+   if (tditrace_ex != NULL) {
+      unsigned int ra = 0;
+      #ifdef __mips__
+      asm volatile("move %0, $ra" : "=r"(ra));
+      #endif
+      if (h->flags & MEM_FLAG_DIRECT) {
+         tditrace_ex(TDIMASK, "@E+gpu_mem_resize %d %x", size, ra);
+         tditrace_ex(TDIMASK, "gpu_mem_resize~%d", size);
+      } else {
+         tditrace_ex(TDIMASK, "gpu_mem_resize*~%d", size);
+      }
+   }
+
    assert(h->magic == MAGIC);
    assert(h->ref_count != 0);
 #ifdef BCG_VC4_DEFRAG
@@ -1185,6 +1264,18 @@
 
    vcos_mutex_unlock((VCOS_MUTEX_T *)&g_mgr.mh);
 
+   if (tditrace_ex != NULL) {
+      if (h->flags & MEM_FLAG_DIRECT) {
+         //tditrace_ex(TDIMASK, "@T-mem_resize");
+         tditrace_ex(TDIMASK, "gpu_free~%d", g_mgr.memInterface->GetInfo(g_mgr.memInterface->context, BEGL_MemFree));
+      } else {
+         //tditrace_ex(TDIMASK, "@A-mem_resize");
+         struct mallinfo mi;
+         mi = mallinfo();
+         tditrace_ex(TDIMASK, "gpu_mi.arena~%d", mi.arena);
+      }
+   }
+
    return res;
 }
 
